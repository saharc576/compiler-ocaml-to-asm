;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

;;; here we REServe enough Quad-words (64-bit "cells") for the free variables
;;; each free variable has 8 bytes reserved for a 64-bit pointer to its value
fvar_tbl:
    resq 87

section .data
const_tbl:
db T_VOID
db T_NIL
db T_BOOL, 0
db T_BOOL, 1
MAKE_LITERAL_STRING "whatever" 
MAKE_LITERAL_SYMBOL(const_tbl+6)
MAKE_LITERAL_CHAR (0)
MAKE_LITERAL_RATIONAL(0,1)
MAKE_LITERAL_RATIONAL(1,1)
MAKE_LITERAL_RATIONAL(-1,1)
MAKE_LITERAL_RATIONAL(2,1)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

global main
section .text
main:
    ;; set up the heap
    mov rdi, GB(2)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0                ; argument count
    push SOB_NIL_ADDRESS  ; lexical environment address
    push T_UNDEFINED      ; return address
    push rbp                    
    mov rbp, rsp                ; anchor the dummy frame

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we simulate the missing (define ...) expressions
    ;; for all the primitive procedures.
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, boolean?)
mov [fvar_tbl+72], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, flonum?)
mov [fvar_tbl+160], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, rational?)
mov [fvar_tbl+296], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, pair?)
mov [fvar_tbl+280], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, null?)
mov [fvar_tbl+256], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char?)
mov [fvar_tbl+104], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string?)
mov [fvar_tbl+352], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, procedure?)
mov [fvar_tbl+288], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol?)
mov [fvar_tbl+360], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
mov [fvar_tbl+328], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
mov [fvar_tbl+336], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
mov [fvar_tbl+344], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
mov [fvar_tbl+232], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
mov [fvar_tbl+368], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
mov [fvar_tbl+96], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
mov [fvar_tbl+200], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, exact_to_inexact)
mov [fvar_tbl+152], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq?)
mov [fvar_tbl+136], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, add)
mov [fvar_tbl+8], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, mul)
mov [fvar_tbl+0], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, div)
mov [fvar_tbl+24], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq)
mov [fvar_tbl+40], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, lt)
mov [fvar_tbl+32], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, numerator)
mov [fvar_tbl+272], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, denominator)
mov [fvar_tbl+128], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, gcd)
mov [fvar_tbl+184], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
mov [fvar_tbl+80], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
mov [fvar_tbl+88], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
mov [fvar_tbl+304], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
mov [fvar_tbl+312], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
mov [fvar_tbl+112], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
mov [fvar_tbl+64], rax

user_code_fragment:
;;; The code you compiled will be added here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.



;START OF CODE of (define map ((lambda (null? car cdr cons apply) ((lambda (map-many map-one) (set! map-many (box map-many)) (set! map-one (box map-one)) (begin (set! map-many (lambda (f lists) (if (null? (car lists)) '() (cons (apply f (map-one car lists)) (map-many f (map-one cdr lists)))))) (set! map-one (lambda (f s) (if (null? s) '() (cons (f (car s)) (map-one f (cdr s)))))) (lambda (f . args) (map-many f args)))) 'whatever 'whatever)) null? car cdr cons apply))



;Start of sub expr 
;((lambda (null? car cdr cons apply) ((lambda (map-many map-one) (set! map-many (box map-many)) (set! map-one (box map-one)) (begin (set! map-many (lambda (f lists) (if (null? (car lists)) '() (cons (apply f (map-one car lists)) (map-many f (map-one cdr lists)))))) (set! map-one (lambda (f s) (if (null? s) '() (cons (f (car s)) (map-one f (cdr s)))))) (lambda (f . args) (map-many f args)))) 'whatever 'whatever)) null? car cdr cons apply)


; Applic

mov rax, qword [fvar_tbl+64]

push rax
;pushed arg apply
mov rax, qword [fvar_tbl+112]

push rax
;pushed arg cons
mov rax, qword [fvar_tbl+88]

push rax
;pushed arg cdr
mov rax, qword [fvar_tbl+80]

push rax
;pushed arg car
mov rax, qword [fvar_tbl+256]

push rax
;pushed arg null?
push 5  ; number of args

;Start of sub expr 
;(lambda (null? car cdr cons apply) ((lambda (map-many map-one) (set! map-many (box map-many)) (set! map-one (box map-one)) (begin (set! map-many (lambda (f lists) (if (null? (car lists)) '() (cons (apply f (map-one car lists)) (map-many f (map-one cdr lists)))))) (set! map-one (lambda (f s) (if (null? s) '() (cons (f (car s)) (map-one f (cdr s)))))) (lambda (f . args) (map-many f args)))) 'whatever 'whatever))

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode2)
jmp Lcont2
Lcode2:
push rbp
mov rbp,rsp

;Start of sub expr 
;((lambda (map-many map-one) (set! map-many (box map-many)) (set! map-one (box map-one)) (begin (set! map-many (lambda (f lists) (if (null? (car lists)) '() (cons (apply f (map-one car lists)) (map-many f (map-one cdr lists)))))) (set! map-one (lambda (f s) (if (null? s) '() (cons (f (car s)) (map-one f (cdr s)))))) (lambda (f . args) (map-many f args)))) 'whatever 'whatever)


; ApplicTP

mov rax, const_tbl+23

push rax
;pushed arg 'whatever
mov rax, const_tbl+23

push rax
;pushed arg 'whatever
push 2  ; number of args

;Start of sub expr 
;(lambda (map-many map-one) (set! map-many (box map-many)) (set! map-one (box map-one)) (begin (set! map-many (lambda (f lists) (if (null? (car lists)) '() (cons (apply f (map-one car lists)) (map-many f (map-one cdr lists)))))) (set! map-one (lambda (f s) (if (null? s) '() (cons (f (car s)) (map-one f (cdr s)))))) (lambda (f . args) (map-many f args))))

MALLOC rbx, (1+1)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 1
loop5:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop5    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop6:
cmp rcx, r8
je end_loop6
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop6
end_loop6:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode4)
jmp Lcont4
Lcode4:
push rbp
mov rbp,rsp
MALLOC rcx, 8*1   ;allocate memory to box param
mov rax, qword [rbp + 8 * (4 + 0)]
mov [rcx], qword rax
mov rax, rcx
mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS

MALLOC rcx, 8*1   ;allocate memory to box param
mov rax, qword [rbp + 8 * (4 + 1)]
mov [rcx], qword rax
mov rax, rcx
mov qword [rbp + 8 * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS


;Start of sub expr 
;(lambda (f lists) (if (null? (car lists)) '() (cons (apply f (map-one car lists)) (map-many f (map-one cdr lists)))))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop8:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop8    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop9:
cmp rcx, r8
je end_loop9
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop9
end_loop9:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode7)
jmp Lcont7
Lcode7:
push rbp
mov rbp,rsp

;Start of sub expr 
;(if (null? (car lists)) '() (cons (apply f (map-one car lists)) (map-many f (map-one cdr lists))))



;Start of sub expr 
;(null? (car lists))


; Applic


;Start of sub expr 
;(car lists)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg lists
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg10
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg10:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (car lists)
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg11
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg11:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse17
mov rax, const_tbl+1

jmp Lexit17
Lelse17:

;Start of sub expr 
;(cons (apply f (map-one car lists)) (map-many f (map-one cdr lists)))


; ApplicTP


;Start of sub expr 
;(map-many f (map-one cdr lists))


; Applic


;Start of sub expr 
;(map-one cdr lists)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg lists
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*2]		;rax<-rib (=minor)

push rax
;pushed arg cdr
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)
mov rax, qword [rax]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg12
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg12:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (map-one cdr lists)
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg f
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)
mov rax, qword [rax]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg13
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg13:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (map-many f (map-one cdr lists))

;Start of sub expr 
;(apply f (map-one car lists))


; Applic


;Start of sub expr 
;(map-one car lists)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg lists
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)

push rax
;pushed arg car
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)
mov rax, qword [rax]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg14
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg14:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (map-one car lists)
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg f
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*4]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg15
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg15:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (apply f (map-one car lists))
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*3]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP16
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP16:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

Lexit17:

leave
ret
Lcont7:

push rax
mov rax, qword [rbp + 8 * (4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS


;Start of sub expr 
;(lambda (f s) (if (null? s) '() (cons (f (car s)) (map-one f (cdr s)))))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop19:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop19    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop20:
cmp rcx, r8
je end_loop20
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop20
end_loop20:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode18)
jmp Lcont18
Lcode18:
push rbp
mov rbp,rsp

;Start of sub expr 
;(if (null? s) '() (cons (f (car s)) (map-one f (cdr s))))



;Start of sub expr 
;(null? s)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg s
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg21
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg21:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse27
mov rax, const_tbl+1

jmp Lexit27
Lelse27:

;Start of sub expr 
;(cons (f (car s)) (map-one f (cdr s)))


; ApplicTP


;Start of sub expr 
;(map-one f (cdr s))


; Applic


;Start of sub expr 
;(cdr s)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg s
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*2]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg22
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg22:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (cdr s)
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg f
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)
mov rax, qword [rax]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg23
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg23:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (map-one f (cdr s))

;Start of sub expr 
;(f (car s))


; Applic


;Start of sub expr 
;(car s)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg s
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg24
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg24:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (car s)
push 1  ; number of args
mov rax, qword [rbp + 8 * (4 + 0)]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg25
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg25:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (f (car s))
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*3]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP26
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP26:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

Lexit27:

leave
ret
Lcont18:

push rax
mov rax, qword [rbp + 8 * (4 + 1)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS


;Start of sub expr 
;(lambda (f . args) (map-many f args))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop29:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop29    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop30:
cmp rcx, r8
je end_loop30
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop30
end_loop30:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode28)
jmp Lcont28
Lcode28:
Start_fix_stack34:   
        mov r8, qword [rsp + 8*2]     ; r8 = params number in stack (=real number)
        
        ; for each optional argument in stack (r8 - params_count) append to list
        cmp r8, 1  ; if equals, add nil and inc argc
        je shift_down_n_add_nil35 
        
        ; else, must loop to append all extra elements and decrease stack size
        sub r8, 1  ; r8 = |only optional args|
        lea r9, [rsp + (WORD_SIZE * 2)]   ; r9 points to argc
        mov r10, [r9]                     ; r10 = argc
        shl r10, 3                        ; argc in bytes
        add r9, r10                       ; r9 points to the last optional argument on stack

        push r9                           ; store the last arg address

        ; we'll now loop and append from last to first all optional arguments
        mov rcx, r8                 ; loop counter = PARAM_COUNT - 'regular params'
        mov r12, SOB_NIL_ADDRESS    ; NIL is the init var
        start_create_nested_pairs32:
        cmp rcx, 0
        je exit_create_nested_pairs32 

        mov r10, qword [r9]         ; get the curr opt arg
        MAKE_PAIR(r11, r10, r12)    ; r11 = Pair(r10, r12)
        mov r12, r11                ; r12 is the pair to return = acc

        sub r9, WORD_SIZE           ; point to the next (=below) arg
        dec rcx
        jmp start_create_nested_pairs32

        exit_create_nested_pairs32:

        pop r9                      ; address of A_n-1
        mov qword [r9], r12         ; put there the list we built                          
        
        ; fix argc (= regular params + 1 )
        mov r15, 1 
        inc r15
        mov qword [rsp + 2*WORD_SIZE], r15

        mov rcx, 2                            ; (ret, env, n) => (0,1,2)
        add rcx, 1             ; loop counter, rcx = 2 + regular params
        sub r9, WORD_SIZE                     ; r9 is the curr cell to occupy

        ; loop to fix frame
        fix_frame33:
        mov r11, rcx
        shl r11, 3                            ; r11 = WORD_SIZE*r11
        mov r12, [rsp + r11]                  ; r12 is the the value we want to move
        mov qword [r9], r12                  ; move it to the next cell to occupy

        cmp rcx, 0
        je fix_stack_pointers36
        ; else update counters and continue
        sub r9, WORD_SIZE                    ; update r9: next cell to occupy
        dec rcx
        jmp fix_frame33
        
      shift_down_n_add_nil35:
        ; shift one cell down = enlarge frame (updates rsp as well)
        INC_FRAME
        jmp Exit_fix_stack34
        
      fix_stack_pointers36:

      mov rsp, r9
      Exit_fix_stack34:

      
      
      push rbp
mov rbp,rsp

;Start of sub expr 
;(map-many f args)


; ApplicTP

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg args
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg f
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)
mov rax, qword [rax]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP31
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP31:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont28:




leave
ret
Lcont4:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP3
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP3:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont2:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg1
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg1:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          mov qword [fvar_tbl+240],rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void




;START OF CODE of (define fold-left ((lambda (null? car cdr) ((lambda (fold-left-loop) (set! fold-left-loop (box fold-left-loop)) (begin (set! fold-left-loop (lambda (f x l) (if (null? l) x (fold-left-loop f (f x (car l)) (cdr l))))) fold-left-loop)) 'whatever)) null? car cdr))



;Start of sub expr 
;((lambda (null? car cdr) ((lambda (fold-left-loop) (set! fold-left-loop (box fold-left-loop)) (begin (set! fold-left-loop (lambda (f x l) (if (null? l) x (fold-left-loop f (f x (car l)) (cdr l))))) fold-left-loop)) 'whatever)) null? car cdr)


; Applic

mov rax, qword [fvar_tbl+88]

push rax
;pushed arg cdr
mov rax, qword [fvar_tbl+80]

push rax
;pushed arg car
mov rax, qword [fvar_tbl+256]

push rax
;pushed arg null?
push 3  ; number of args

;Start of sub expr 
;(lambda (null? car cdr) ((lambda (fold-left-loop) (set! fold-left-loop (box fold-left-loop)) (begin (set! fold-left-loop (lambda (f x l) (if (null? l) x (fold-left-loop f (f x (car l)) (cdr l))))) fold-left-loop)) 'whatever))

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode38)
jmp Lcont38
Lcode38:
push rbp
mov rbp,rsp

;Start of sub expr 
;((lambda (fold-left-loop) (set! fold-left-loop (box fold-left-loop)) (begin (set! fold-left-loop (lambda (f x l) (if (null? l) x (fold-left-loop f (f x (car l)) (cdr l))))) fold-left-loop)) 'whatever)


; ApplicTP

mov rax, const_tbl+23

push rax
;pushed arg 'whatever
push 1  ; number of args

;Start of sub expr 
;(lambda (fold-left-loop) (set! fold-left-loop (box fold-left-loop)) (begin (set! fold-left-loop (lambda (f x l) (if (null? l) x (fold-left-loop f (f x (car l)) (cdr l))))) fold-left-loop))

MALLOC rbx, (1+1)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 1
loop41:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop41    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop42:
cmp rcx, r8
je end_loop42
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop42
end_loop42:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode40)
jmp Lcont40
Lcode40:
push rbp
mov rbp,rsp
MALLOC rcx, 8*1   ;allocate memory to box param
mov rax, qword [rbp + 8 * (4 + 0)]
mov [rcx], qword rax
mov rax, rcx
mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS


;Start of sub expr 
;(lambda (f x l) (if (null? l) x (fold-left-loop f (f x (car l)) (cdr l))))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop44:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop44    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop45:
cmp rcx, r8
je end_loop45
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop45
end_loop45:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode43)
jmp Lcont43
Lcode43:
push rbp
mov rbp,rsp

;Start of sub expr 
;(if (null? l) x (fold-left-loop f (f x (car l)) (cdr l)))



;Start of sub expr 
;(null? l)


; Applic

mov rax, qword [rbp + 8 * (4 + 2)]

push rax
;pushed arg l
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg46
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg46:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse51
mov rax, qword [rbp + 8 * (4 + 1)]

jmp Lexit51
Lelse51:

;Start of sub expr 
;(fold-left-loop f (f x (car l)) (cdr l))


; ApplicTP


;Start of sub expr 
;(cdr l)


; Applic

mov rax, qword [rbp + 8 * (4 + 2)]

push rax
;pushed arg l
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*2]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg47
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg47:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (cdr l)

;Start of sub expr 
;(f x (car l))


; Applic


;Start of sub expr 
;(car l)


; Applic

mov rax, qword [rbp + 8 * (4 + 2)]

push rax
;pushed arg l
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg48
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg48:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (car l)
mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg x
push 2  ; number of args
mov rax, qword [rbp + 8 * (4 + 0)]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg49
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg49:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (f x (car l))
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg f
push 3  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)
mov rax, qword [rax]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP50
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP50:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 3
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

Lexit51:

leave
ret
Lcont43:

push rax
mov rax, qword [rbp + 8 * (4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS

mov rax, qword [rbp + 8 * (4 + 0)]
mov rax, qword [rax]



leave
ret
Lcont40:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP39
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP39:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 1
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont38:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg37
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg37:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          mov qword [fvar_tbl+168],rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void




;START OF CODE of (define fold-right ((lambda (null? car cdr) ((lambda (fold-right-loop) (set! fold-right-loop (box fold-right-loop)) (begin (set! fold-right-loop (lambda (f x lst) (if (null? lst) x (f (car lst) (fold-right-loop f x (cdr lst)))))) fold-right-loop)) 'whatever)) null? car cdr))



;Start of sub expr 
;((lambda (null? car cdr) ((lambda (fold-right-loop) (set! fold-right-loop (box fold-right-loop)) (begin (set! fold-right-loop (lambda (f x lst) (if (null? lst) x (f (car lst) (fold-right-loop f x (cdr lst)))))) fold-right-loop)) 'whatever)) null? car cdr)


; Applic

mov rax, qword [fvar_tbl+88]

push rax
;pushed arg cdr
mov rax, qword [fvar_tbl+80]

push rax
;pushed arg car
mov rax, qword [fvar_tbl+256]

push rax
;pushed arg null?
push 3  ; number of args

;Start of sub expr 
;(lambda (null? car cdr) ((lambda (fold-right-loop) (set! fold-right-loop (box fold-right-loop)) (begin (set! fold-right-loop (lambda (f x lst) (if (null? lst) x (f (car lst) (fold-right-loop f x (cdr lst)))))) fold-right-loop)) 'whatever))

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode53)
jmp Lcont53
Lcode53:
push rbp
mov rbp,rsp

;Start of sub expr 
;((lambda (fold-right-loop) (set! fold-right-loop (box fold-right-loop)) (begin (set! fold-right-loop (lambda (f x lst) (if (null? lst) x (f (car lst) (fold-right-loop f x (cdr lst)))))) fold-right-loop)) 'whatever)


; ApplicTP

mov rax, const_tbl+23

push rax
;pushed arg 'whatever
push 1  ; number of args

;Start of sub expr 
;(lambda (fold-right-loop) (set! fold-right-loop (box fold-right-loop)) (begin (set! fold-right-loop (lambda (f x lst) (if (null? lst) x (f (car lst) (fold-right-loop f x (cdr lst)))))) fold-right-loop))

MALLOC rbx, (1+1)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 1
loop56:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop56    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop57:
cmp rcx, r8
je end_loop57
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop57
end_loop57:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode55)
jmp Lcont55
Lcode55:
push rbp
mov rbp,rsp
MALLOC rcx, 8*1   ;allocate memory to box param
mov rax, qword [rbp + 8 * (4 + 0)]
mov [rcx], qword rax
mov rax, rcx
mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS


;Start of sub expr 
;(lambda (f x lst) (if (null? lst) x (f (car lst) (fold-right-loop f x (cdr lst)))))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop59:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop59    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop60:
cmp rcx, r8
je end_loop60
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop60
end_loop60:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode58)
jmp Lcont58
Lcode58:
push rbp
mov rbp,rsp

;Start of sub expr 
;(if (null? lst) x (f (car lst) (fold-right-loop f x (cdr lst))))



;Start of sub expr 
;(null? lst)


; Applic

mov rax, qword [rbp + 8 * (4 + 2)]

push rax
;pushed arg lst
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg61
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg61:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse66
mov rax, qword [rbp + 8 * (4 + 1)]

jmp Lexit66
Lelse66:

;Start of sub expr 
;(f (car lst) (fold-right-loop f x (cdr lst)))


; ApplicTP


;Start of sub expr 
;(fold-right-loop f x (cdr lst))


; Applic


;Start of sub expr 
;(cdr lst)


; Applic

mov rax, qword [rbp + 8 * (4 + 2)]

push rax
;pushed arg lst
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*2]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg62
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg62:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (cdr lst)
mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg x
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg f
push 3  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)
mov rax, qword [rax]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg63
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg63:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (fold-right-loop f x (cdr lst))

;Start of sub expr 
;(car lst)


; Applic

mov rax, qword [rbp + 8 * (4 + 2)]

push rax
;pushed arg lst
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg64
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg64:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (car lst)
push 2  ; number of args
mov rax, qword [rbp + 8 * (4 + 0)]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP65
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP65:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

Lexit66:

leave
ret
Lcont58:

push rax
mov rax, qword [rbp + 8 * (4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS

mov rax, qword [rbp + 8 * (4 + 0)]
mov rax, qword [rax]



leave
ret
Lcont55:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP54
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP54:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 1
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont53:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg52
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg52:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          mov qword [fvar_tbl+176],rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void




;START OF CODE of (define cons* ((lambda (null? car cdr list) ((lambda (cons*-rec cons**) (set! cons*-rec (box cons*-rec)) (begin (set! cons*-rec (lambda (lst) (if (null? (cdr lst)) (car lst) (cons (car lst) (cons*-rec (cdr lst)))))) (set! cons** (lambda x (cons*-rec x))) cons**)) 'whatever 'whatever)) null? car cdr list))



;Start of sub expr 
;((lambda (null? car cdr list) ((lambda (cons*-rec cons**) (set! cons*-rec (box cons*-rec)) (begin (set! cons*-rec (lambda (lst) (if (null? (cdr lst)) (car lst) (cons (car lst) (cons*-rec (cdr lst)))))) (set! cons** (lambda x (cons*-rec x))) cons**)) 'whatever 'whatever)) null? car cdr list)


; Applic

mov rax, qword [fvar_tbl+216]

push rax
;pushed arg list
mov rax, qword [fvar_tbl+88]

push rax
;pushed arg cdr
mov rax, qword [fvar_tbl+80]

push rax
;pushed arg car
mov rax, qword [fvar_tbl+256]

push rax
;pushed arg null?
push 4  ; number of args

;Start of sub expr 
;(lambda (null? car cdr list) ((lambda (cons*-rec cons**) (set! cons*-rec (box cons*-rec)) (begin (set! cons*-rec (lambda (lst) (if (null? (cdr lst)) (car lst) (cons (car lst) (cons*-rec (cdr lst)))))) (set! cons** (lambda x (cons*-rec x))) cons**)) 'whatever 'whatever))

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode68)
jmp Lcont68
Lcode68:
push rbp
mov rbp,rsp

;Start of sub expr 
;((lambda (cons*-rec cons**) (set! cons*-rec (box cons*-rec)) (begin (set! cons*-rec (lambda (lst) (if (null? (cdr lst)) (car lst) (cons (car lst) (cons*-rec (cdr lst)))))) (set! cons** (lambda x (cons*-rec x))) cons**)) 'whatever 'whatever)


; ApplicTP

mov rax, const_tbl+23

push rax
;pushed arg 'whatever
mov rax, const_tbl+23

push rax
;pushed arg 'whatever
push 2  ; number of args

;Start of sub expr 
;(lambda (cons*-rec cons**) (set! cons*-rec (box cons*-rec)) (begin (set! cons*-rec (lambda (lst) (if (null? (cdr lst)) (car lst) (cons (car lst) (cons*-rec (cdr lst)))))) (set! cons** (lambda x (cons*-rec x))) cons**))

MALLOC rbx, (1+1)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 1
loop71:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop71    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop72:
cmp rcx, r8
je end_loop72
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop72
end_loop72:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode70)
jmp Lcont70
Lcode70:
push rbp
mov rbp,rsp
MALLOC rcx, 8*1   ;allocate memory to box param
mov rax, qword [rbp + 8 * (4 + 0)]
mov [rcx], qword rax
mov rax, rcx
mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS


;Start of sub expr 
;(lambda (lst) (if (null? (cdr lst)) (car lst) (cons (car lst) (cons*-rec (cdr lst)))))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop74:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop74    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop75:
cmp rcx, r8
je end_loop75
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop75
end_loop75:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode73)
jmp Lcont73
Lcode73:
push rbp
mov rbp,rsp

;Start of sub expr 
;(if (null? (cdr lst)) (car lst) (cons (car lst) (cons*-rec (cdr lst))))



;Start of sub expr 
;(null? (cdr lst))


; Applic


;Start of sub expr 
;(cdr lst)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg lst
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*2]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg76
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg76:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (cdr lst)
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg77
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg77:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse83

;Start of sub expr 
;(car lst)


; ApplicTP

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg lst
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP78
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP78:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 1
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

jmp Lexit83
Lelse83:

;Start of sub expr 
;(cons (car lst) (cons*-rec (cdr lst)))


; ApplicTP


;Start of sub expr 
;(cons*-rec (cdr lst))


; Applic


;Start of sub expr 
;(cdr lst)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg lst
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*2]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg79
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg79:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (cdr lst)
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)
mov rax, qword [rax]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg80
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg80:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (cons*-rec (cdr lst))

;Start of sub expr 
;(car lst)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg lst
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg81
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg81:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (car lst)
push 2  ; number of args
mov rax, qword [fvar_tbl+112]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP82
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP82:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

Lexit83:

leave
ret
Lcont73:

push rax
mov rax, qword [rbp + 8 * (4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS


;Start of sub expr 
;(lambda x (cons*-rec x))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop85:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop85    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop86:
cmp rcx, r8
je end_loop86
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop86
end_loop86:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode84)
jmp Lcont84
Lcode84:
Start_fix_stack90:   
        mov r8, qword [rsp + 8*2]     ; r8 = params number in stack (=real number)
        
        ; for each optional argument in stack (r8 - params_count) append to list
        cmp r8, 0  ; if equals, add nil and inc argc
        je shift_down_n_add_nil91 
        
        ; else, must loop to append all extra elements and decrease stack size
        sub r8, 0  ; r8 = |only optional args|
        lea r9, [rsp + (WORD_SIZE * 2)]   ; r9 points to argc
        mov r10, [r9]                     ; r10 = argc
        shl r10, 3                        ; argc in bytes
        add r9, r10                       ; r9 points to the last optional argument on stack

        push r9                           ; store the last arg address

        ; we'll now loop and append from last to first all optional arguments
        mov rcx, r8                 ; loop counter = PARAM_COUNT - 'regular params'
        mov r12, SOB_NIL_ADDRESS    ; NIL is the init var
        start_create_nested_pairs88:
        cmp rcx, 0
        je exit_create_nested_pairs88 

        mov r10, qword [r9]         ; get the curr opt arg
        MAKE_PAIR(r11, r10, r12)    ; r11 = Pair(r10, r12)
        mov r12, r11                ; r12 is the pair to return = acc

        sub r9, WORD_SIZE           ; point to the next (=below) arg
        dec rcx
        jmp start_create_nested_pairs88

        exit_create_nested_pairs88:

        pop r9                      ; address of A_n-1
        mov qword [r9], r12         ; put there the list we built                          
        
        ; fix argc (= regular params + 1 )
        mov r15, 0 
        inc r15
        mov qword [rsp + 2*WORD_SIZE], r15

        mov rcx, 2                            ; (ret, env, n) => (0,1,2)
        add rcx, 0             ; loop counter, rcx = 2 + regular params
        sub r9, WORD_SIZE                     ; r9 is the curr cell to occupy

        ; loop to fix frame
        fix_frame89:
        mov r11, rcx
        shl r11, 3                            ; r11 = WORD_SIZE*r11
        mov r12, [rsp + r11]                  ; r12 is the the value we want to move
        mov qword [r9], r12                  ; move it to the next cell to occupy

        cmp rcx, 0
        je fix_stack_pointers92
        ; else update counters and continue
        sub r9, WORD_SIZE                    ; update r9: next cell to occupy
        dec rcx
        jmp fix_frame89
        
      shift_down_n_add_nil91:
        ; shift one cell down = enlarge frame (updates rsp as well)
        INC_FRAME
        jmp Exit_fix_stack90
        
      fix_stack_pointers92:

      mov rsp, r9
      Exit_fix_stack90:

      
      
      push rbp
mov rbp,rsp

;Start of sub expr 
;(cons*-rec x)


; ApplicTP

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)
mov rax, qword [rax]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP87
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP87:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 1
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont84:

mov qword [rbp + 8 * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS

mov rax, qword [rbp + 8 * (4 + 1)]



leave
ret
Lcont70:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP69
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP69:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont68:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg67
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg67:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          mov qword [fvar_tbl+120],rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void




;START OF CODE of (define append ((lambda (null? fold-right cons) (lambda args (fold-right (lambda (e a) (if (null? a) e (fold-right cons a e))) '() args))) null? fold-right cons))



;Start of sub expr 
;((lambda (null? fold-right cons) (lambda args (fold-right (lambda (e a) (if (null? a) e (fold-right cons a e))) '() args))) null? fold-right cons)


; Applic

mov rax, qword [fvar_tbl+112]

push rax
;pushed arg cons
mov rax, qword [fvar_tbl+176]

push rax
;pushed arg fold-right
mov rax, qword [fvar_tbl+256]

push rax
;pushed arg null?
push 3  ; number of args

;Start of sub expr 
;(lambda (null? fold-right cons) (lambda args (fold-right (lambda (e a) (if (null? a) e (fold-right cons a e))) '() args)))

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode94)
jmp Lcont94
Lcode94:
push rbp
mov rbp,rsp

;Start of sub expr 
;(lambda args (fold-right (lambda (e a) (if (null? a) e (fold-right cons a e))) '() args))

MALLOC rbx, (1+1)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 1
loop96:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop96    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop97:
cmp rcx, r8
je end_loop97
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop97
end_loop97:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode95)
jmp Lcont95
Lcode95:
Start_fix_stack107:   
        mov r8, qword [rsp + 8*2]     ; r8 = params number in stack (=real number)
        
        ; for each optional argument in stack (r8 - params_count) append to list
        cmp r8, 0  ; if equals, add nil and inc argc
        je shift_down_n_add_nil108 
        
        ; else, must loop to append all extra elements and decrease stack size
        sub r8, 0  ; r8 = |only optional args|
        lea r9, [rsp + (WORD_SIZE * 2)]   ; r9 points to argc
        mov r10, [r9]                     ; r10 = argc
        shl r10, 3                        ; argc in bytes
        add r9, r10                       ; r9 points to the last optional argument on stack

        push r9                           ; store the last arg address

        ; we'll now loop and append from last to first all optional arguments
        mov rcx, r8                 ; loop counter = PARAM_COUNT - 'regular params'
        mov r12, SOB_NIL_ADDRESS    ; NIL is the init var
        start_create_nested_pairs105:
        cmp rcx, 0
        je exit_create_nested_pairs105 

        mov r10, qword [r9]         ; get the curr opt arg
        MAKE_PAIR(r11, r10, r12)    ; r11 = Pair(r10, r12)
        mov r12, r11                ; r12 is the pair to return = acc

        sub r9, WORD_SIZE           ; point to the next (=below) arg
        dec rcx
        jmp start_create_nested_pairs105

        exit_create_nested_pairs105:

        pop r9                      ; address of A_n-1
        mov qword [r9], r12         ; put there the list we built                          
        
        ; fix argc (= regular params + 1 )
        mov r15, 0 
        inc r15
        mov qword [rsp + 2*WORD_SIZE], r15

        mov rcx, 2                            ; (ret, env, n) => (0,1,2)
        add rcx, 0             ; loop counter, rcx = 2 + regular params
        sub r9, WORD_SIZE                     ; r9 is the curr cell to occupy

        ; loop to fix frame
        fix_frame106:
        mov r11, rcx
        shl r11, 3                            ; r11 = WORD_SIZE*r11
        mov r12, [rsp + r11]                  ; r12 is the the value we want to move
        mov qword [r9], r12                  ; move it to the next cell to occupy

        cmp rcx, 0
        je fix_stack_pointers109
        ; else update counters and continue
        sub r9, WORD_SIZE                    ; update r9: next cell to occupy
        dec rcx
        jmp fix_frame106
        
      shift_down_n_add_nil108:
        ; shift one cell down = enlarge frame (updates rsp as well)
        INC_FRAME
        jmp Exit_fix_stack107
        
      fix_stack_pointers109:

      mov rsp, r9
      Exit_fix_stack107:

      
      
      push rbp
mov rbp,rsp

;Start of sub expr 
;(fold-right (lambda (e a) (if (null? a) e (fold-right cons a e))) '() args)


; ApplicTP

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg args
mov rax, const_tbl+1

push rax
;pushed arg '()

;Start of sub expr 
;(lambda (e a) (if (null? a) e (fold-right cons a e)))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop99:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop99    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop100:
cmp rcx, r8
je end_loop100
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop100
end_loop100:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode98)
jmp Lcont98
Lcode98:
push rbp
mov rbp,rsp

;Start of sub expr 
;(if (null? a) e (fold-right cons a e))



;Start of sub expr 
;(null? a)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg a
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg101
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg101:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse103
mov rax, qword [rbp + 8 * (4 + 0)]

jmp Lexit103
Lelse103:

;Start of sub expr 
;(fold-right cons a e)


; ApplicTP

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg e
mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg a
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*2]		;rax<-rib (=minor)

push rax
;pushed arg cons
push 3  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP102
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP102:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 3
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

Lexit103:

leave
ret
Lcont98:


push rax
;pushed arg (lambda (e a) (if (null? a) e (fold-right cons a e)))
push 3  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP104
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP104:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 3
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont95:


leave
ret
Lcont94:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg93
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg93:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          mov qword [fvar_tbl+56],rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void




;START OF CODE of (define list (lambda x x))



;Start of sub expr 
;(lambda x x)

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode110)
jmp Lcont110
Lcode110:
Start_fix_stack113:   
        mov r8, qword [rsp + 8*2]     ; r8 = params number in stack (=real number)
        
        ; for each optional argument in stack (r8 - params_count) append to list
        cmp r8, 0  ; if equals, add nil and inc argc
        je shift_down_n_add_nil114 
        
        ; else, must loop to append all extra elements and decrease stack size
        sub r8, 0  ; r8 = |only optional args|
        lea r9, [rsp + (WORD_SIZE * 2)]   ; r9 points to argc
        mov r10, [r9]                     ; r10 = argc
        shl r10, 3                        ; argc in bytes
        add r9, r10                       ; r9 points to the last optional argument on stack

        push r9                           ; store the last arg address

        ; we'll now loop and append from last to first all optional arguments
        mov rcx, r8                 ; loop counter = PARAM_COUNT - 'regular params'
        mov r12, SOB_NIL_ADDRESS    ; NIL is the init var
        start_create_nested_pairs111:
        cmp rcx, 0
        je exit_create_nested_pairs111 

        mov r10, qword [r9]         ; get the curr opt arg
        MAKE_PAIR(r11, r10, r12)    ; r11 = Pair(r10, r12)
        mov r12, r11                ; r12 is the pair to return = acc

        sub r9, WORD_SIZE           ; point to the next (=below) arg
        dec rcx
        jmp start_create_nested_pairs111

        exit_create_nested_pairs111:

        pop r9                      ; address of A_n-1
        mov qword [r9], r12         ; put there the list we built                          
        
        ; fix argc (= regular params + 1 )
        mov r15, 0 
        inc r15
        mov qword [rsp + 2*WORD_SIZE], r15

        mov rcx, 2                            ; (ret, env, n) => (0,1,2)
        add rcx, 0             ; loop counter, rcx = 2 + regular params
        sub r9, WORD_SIZE                     ; r9 is the curr cell to occupy

        ; loop to fix frame
        fix_frame112:
        mov r11, rcx
        shl r11, 3                            ; r11 = WORD_SIZE*r11
        mov r12, [rsp + r11]                  ; r12 is the the value we want to move
        mov qword [r9], r12                  ; move it to the next cell to occupy

        cmp rcx, 0
        je fix_stack_pointers115
        ; else update counters and continue
        sub r9, WORD_SIZE                    ; update r9: next cell to occupy
        dec rcx
        jmp fix_frame112
        
      shift_down_n_add_nil114:
        ; shift one cell down = enlarge frame (updates rsp as well)
        INC_FRAME
        jmp Exit_fix_stack113
        
      fix_stack_pointers115:

      mov rsp, r9
      Exit_fix_stack113:

      
      
      push rbp
mov rbp,rsp
mov rax, qword [rbp + 8 * (4 + 0)]

leave
ret
Lcont110:

mov qword [fvar_tbl+216],rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void




;START OF CODE of (define list? ((lambda (null? pair? cdr) ((lambda (list?-loop) (set! list?-loop (box list?-loop)) (begin (set! list?-loop (lambda (x) (or (null? x) (if (pair? x) (list?-loop (cdr x)) #f)))) list?-loop)) 'whatever)) null? pair? cdr))



;Start of sub expr 
;((lambda (null? pair? cdr) ((lambda (list?-loop) (set! list?-loop (box list?-loop)) (begin (set! list?-loop (lambda (x) (or (null? x) (if (pair? x) (list?-loop (cdr x)) #f)))) list?-loop)) 'whatever)) null? pair? cdr)


; Applic

mov rax, qword [fvar_tbl+88]

push rax
;pushed arg cdr
mov rax, qword [fvar_tbl+280]

push rax
;pushed arg pair?
mov rax, qword [fvar_tbl+256]

push rax
;pushed arg null?
push 3  ; number of args

;Start of sub expr 
;(lambda (null? pair? cdr) ((lambda (list?-loop) (set! list?-loop (box list?-loop)) (begin (set! list?-loop (lambda (x) (or (null? x) (if (pair? x) (list?-loop (cdr x)) #f)))) list?-loop)) 'whatever))

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode117)
jmp Lcont117
Lcode117:
push rbp
mov rbp,rsp

;Start of sub expr 
;((lambda (list?-loop) (set! list?-loop (box list?-loop)) (begin (set! list?-loop (lambda (x) (or (null? x) (if (pair? x) (list?-loop (cdr x)) #f)))) list?-loop)) 'whatever)


; ApplicTP

mov rax, const_tbl+23

push rax
;pushed arg 'whatever
push 1  ; number of args

;Start of sub expr 
;(lambda (list?-loop) (set! list?-loop (box list?-loop)) (begin (set! list?-loop (lambda (x) (or (null? x) (if (pair? x) (list?-loop (cdr x)) #f)))) list?-loop))

MALLOC rbx, (1+1)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 1
loop120:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop120    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop121:
cmp rcx, r8
je end_loop121
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop121
end_loop121:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode119)
jmp Lcont119
Lcode119:
push rbp
mov rbp,rsp
MALLOC rcx, 8*1   ;allocate memory to box param
mov rax, qword [rbp + 8 * (4 + 0)]
mov [rcx], qword rax
mov rax, rcx
mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS


;Start of sub expr 
;(lambda (x) (or (null? x) (if (pair? x) (list?-loop (cdr x)) #f)))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop123:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop123    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop124:
cmp rcx, r8
je end_loop124
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop124
end_loop124:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode122)
jmp Lcont122
Lcode122:
push rbp
mov rbp,rsp

;Start of sub expr 
;(null? x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg125
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg125:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          cmp rax, SOB_FALSE_ADDRESS
jne Lexit130

;Start of sub expr 
;(if (pair? x) (list?-loop (cdr x)) #f)



;Start of sub expr 
;(pair? x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg126
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg126:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse129

;Start of sub expr 
;(list?-loop (cdr x))


; ApplicTP


;Start of sub expr 
;(cdr x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*2]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg127
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg127:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (cdr x)
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)
mov rax, qword [rax]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP128
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP128:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 1
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

jmp Lexit129
Lelse129:
mov rax, const_tbl+2

Lexit129:
Lexit130:

leave
ret
Lcont122:

push rax
mov rax, qword [rbp + 8 * (4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS

mov rax, qword [rbp + 8 * (4 + 0)]
mov rax, qword [rax]



leave
ret
Lcont119:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP118
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP118:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 1
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont117:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg116
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg116:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          mov qword [fvar_tbl+224],rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void




;START OF CODE of (define make-string ((lambda (null? car) (lambda (x . y) (if (null? y) (make-string x #\x0) (make-string x (car y))))) null? car))



;Start of sub expr 
;((lambda (null? car) (lambda (x . y) (if (null? y) (make-string x #\x0) (make-string x (car y))))) null? car)


; Applic

mov rax, qword [fvar_tbl+80]

push rax
;pushed arg car
mov rax, qword [fvar_tbl+256]

push rax
;pushed arg null?
push 2  ; number of args

;Start of sub expr 
;(lambda (null? car) (lambda (x . y) (if (null? y) (make-string x #\x0) (make-string x (car y)))))

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode132)
jmp Lcont132
Lcode132:
push rbp
mov rbp,rsp

;Start of sub expr 
;(lambda (x . y) (if (null? y) (make-string x #\x0) (make-string x (car y))))

MALLOC rbx, (1+1)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 1
loop134:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop134    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop135:
cmp rcx, r8
je end_loop135
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop135
end_loop135:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode133)
jmp Lcont133
Lcode133:
Start_fix_stack143:   
        mov r8, qword [rsp + 8*2]     ; r8 = params number in stack (=real number)
        
        ; for each optional argument in stack (r8 - params_count) append to list
        cmp r8, 1  ; if equals, add nil and inc argc
        je shift_down_n_add_nil144 
        
        ; else, must loop to append all extra elements and decrease stack size
        sub r8, 1  ; r8 = |only optional args|
        lea r9, [rsp + (WORD_SIZE * 2)]   ; r9 points to argc
        mov r10, [r9]                     ; r10 = argc
        shl r10, 3                        ; argc in bytes
        add r9, r10                       ; r9 points to the last optional argument on stack

        push r9                           ; store the last arg address

        ; we'll now loop and append from last to first all optional arguments
        mov rcx, r8                 ; loop counter = PARAM_COUNT - 'regular params'
        mov r12, SOB_NIL_ADDRESS    ; NIL is the init var
        start_create_nested_pairs141:
        cmp rcx, 0
        je exit_create_nested_pairs141 

        mov r10, qword [r9]         ; get the curr opt arg
        MAKE_PAIR(r11, r10, r12)    ; r11 = Pair(r10, r12)
        mov r12, r11                ; r12 is the pair to return = acc

        sub r9, WORD_SIZE           ; point to the next (=below) arg
        dec rcx
        jmp start_create_nested_pairs141

        exit_create_nested_pairs141:

        pop r9                      ; address of A_n-1
        mov qword [r9], r12         ; put there the list we built                          
        
        ; fix argc (= regular params + 1 )
        mov r15, 1 
        inc r15
        mov qword [rsp + 2*WORD_SIZE], r15

        mov rcx, 2                            ; (ret, env, n) => (0,1,2)
        add rcx, 1             ; loop counter, rcx = 2 + regular params
        sub r9, WORD_SIZE                     ; r9 is the curr cell to occupy

        ; loop to fix frame
        fix_frame142:
        mov r11, rcx
        shl r11, 3                            ; r11 = WORD_SIZE*r11
        mov r12, [rsp + r11]                  ; r12 is the the value we want to move
        mov qword [r9], r12                  ; move it to the next cell to occupy

        cmp rcx, 0
        je fix_stack_pointers145
        ; else update counters and continue
        sub r9, WORD_SIZE                    ; update r9: next cell to occupy
        dec rcx
        jmp fix_frame142
        
      shift_down_n_add_nil144:
        ; shift one cell down = enlarge frame (updates rsp as well)
        INC_FRAME
        jmp Exit_fix_stack143
        
      fix_stack_pointers145:

      mov rsp, r9
      Exit_fix_stack143:

      
      
      push rbp
mov rbp,rsp

;Start of sub expr 
;(if (null? y) (make-string x #\x0) (make-string x (car y)))



;Start of sub expr 
;(null? y)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg136
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg136:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse140

;Start of sub expr 
;(make-string x #\x0)


; ApplicTP

mov rax, const_tbl+32

push rax
;pushed arg #\x0
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 2  ; number of args
mov rax, qword [fvar_tbl+232]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP137
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP137:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

jmp Lexit140
Lelse140:

;Start of sub expr 
;(make-string x (car y))


; ApplicTP


;Start of sub expr 
;(car y)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg138
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg138:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (car y)
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 2  ; number of args
mov rax, qword [fvar_tbl+232]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP139
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP139:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

Lexit140:

leave
ret
Lcont133:


leave
ret
Lcont132:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg131
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg131:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          mov qword [fvar_tbl+232],rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void




;START OF CODE of (define not (lambda (x) (if x #f #t)))



;Start of sub expr 
;(lambda (x) (if x #f #t))

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode146)
jmp Lcont146
Lcode146:
push rbp
mov rbp,rsp

;Start of sub expr 
;(if x #f #t)


mov rax, qword [rbp + 8 * (4 + 0)]

cmp rax, SOB_FALSE_ADDRESS
je Lelse147
mov rax, const_tbl+2

jmp Lexit147
Lelse147:
mov rax, const_tbl+4

Lexit147:

leave
ret
Lcont146:

mov qword [fvar_tbl+248],rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void




;START OF CODE of ((lambda (flonum? rational? exact->inexact fold-left map _+ _* _/ _= _< car cdr null?) ((lambda (^numeric-op-dispatcher) (set! + (lambda x (fold-left (^numeric-op-dispatcher _+) 0 x))) (set! * (lambda x (fold-left (^numeric-op-dispatcher _*) 1 x))) (set! / ((lambda (/) (lambda (x . y) (if (null? y) (/ 1 x) (fold-left / x y)))) (^numeric-op-dispatcher _/))) ((lambda (^comparator) (set! = (^comparator (^numeric-op-dispatcher _=))) (set! < (^comparator (^numeric-op-dispatcher _<)))) (lambda (op) ((lambda (comparator) (set! comparator (box comparator)) (begin (set! comparator (lambda (x ys) (or (null? ys) (if (op x (car ys)) (comparator (car ys) (cdr ys)) #f)))) (lambda (x . y) (comparator x y)))) 'whatever)))) (lambda (op) (lambda (x y) (if (if (flonum? x) (rational? y) #f) (op x (exact->inexact y)) (if (if (rational? x) (flonum? y) #f) (op (exact->inexact x) y) (op x y))))))) flonum? rational? exact->inexact fold-left map + * / = < car cdr null?)



;Start of sub expr 
;((lambda (flonum? rational? exact->inexact fold-left map _+ _* _/ _= _< car cdr null?) ((lambda (^numeric-op-dispatcher) (set! + (lambda x (fold-left (^numeric-op-dispatcher _+) 0 x))) (set! * (lambda x (fold-left (^numeric-op-dispatcher _*) 1 x))) (set! / ((lambda (/) (lambda (x . y) (if (null? y) (/ 1 x) (fold-left / x y)))) (^numeric-op-dispatcher _/))) ((lambda (^comparator) (set! = (^comparator (^numeric-op-dispatcher _=))) (set! < (^comparator (^numeric-op-dispatcher _<)))) (lambda (op) ((lambda (comparator) (set! comparator (box comparator)) (begin (set! comparator (lambda (x ys) (or (null? ys) (if (op x (car ys)) (comparator (car ys) (cdr ys)) #f)))) (lambda (x . y) (comparator x y)))) 'whatever)))) (lambda (op) (lambda (x y) (if (if (flonum? x) (rational? y) #f) (op x (exact->inexact y)) (if (if (rational? x) (flonum? y) #f) (op (exact->inexact x) y) (op x y))))))) flonum? rational? exact->inexact fold-left map + * / = < car cdr null?)


; Applic

mov rax, qword [fvar_tbl+256]

push rax
;pushed arg null?
mov rax, qword [fvar_tbl+88]

push rax
;pushed arg cdr
mov rax, qword [fvar_tbl+80]

push rax
;pushed arg car
mov rax, qword [fvar_tbl+32]

push rax
;pushed arg <
mov rax, qword [fvar_tbl+40]

push rax
;pushed arg =
mov rax, qword [fvar_tbl+24]

push rax
;pushed arg /
mov rax, qword [fvar_tbl+0]

push rax
;pushed arg *
mov rax, qword [fvar_tbl+8]

push rax
;pushed arg +
mov rax, qword [fvar_tbl+240]

push rax
;pushed arg map
mov rax, qword [fvar_tbl+168]

push rax
;pushed arg fold-left
mov rax, qword [fvar_tbl+152]

push rax
;pushed arg exact->inexact
mov rax, qword [fvar_tbl+296]

push rax
;pushed arg rational?
mov rax, qword [fvar_tbl+160]

push rax
;pushed arg flonum?
push 13  ; number of args

;Start of sub expr 
;(lambda (flonum? rational? exact->inexact fold-left map _+ _* _/ _= _< car cdr null?) ((lambda (^numeric-op-dispatcher) (set! + (lambda x (fold-left (^numeric-op-dispatcher _+) 0 x))) (set! * (lambda x (fold-left (^numeric-op-dispatcher _*) 1 x))) (set! / ((lambda (/) (lambda (x . y) (if (null? y) (/ 1 x) (fold-left / x y)))) (^numeric-op-dispatcher _/))) ((lambda (^comparator) (set! = (^comparator (^numeric-op-dispatcher _=))) (set! < (^comparator (^numeric-op-dispatcher _<)))) (lambda (op) ((lambda (comparator) (set! comparator (box comparator)) (begin (set! comparator (lambda (x ys) (or (null? ys) (if (op x (car ys)) (comparator (car ys) (cdr ys)) #f)))) (lambda (x . y) (comparator x y)))) 'whatever)))) (lambda (op) (lambda (x y) (if (if (flonum? x) (rational? y) #f) (op x (exact->inexact y)) (if (if (rational? x) (flonum? y) #f) (op (exact->inexact x) y) (op x y)))))))

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode149)
jmp Lcont149
Lcode149:
push rbp
mov rbp,rsp

;Start of sub expr 
;((lambda (^numeric-op-dispatcher) (set! + (lambda x (fold-left (^numeric-op-dispatcher _+) 0 x))) (set! * (lambda x (fold-left (^numeric-op-dispatcher _*) 1 x))) (set! / ((lambda (/) (lambda (x . y) (if (null? y) (/ 1 x) (fold-left / x y)))) (^numeric-op-dispatcher _/))) ((lambda (^comparator) (set! = (^comparator (^numeric-op-dispatcher _=))) (set! < (^comparator (^numeric-op-dispatcher _<)))) (lambda (op) ((lambda (comparator) (set! comparator (box comparator)) (begin (set! comparator (lambda (x ys) (or (null? ys) (if (op x (car ys)) (comparator (car ys) (cdr ys)) #f)))) (lambda (x . y) (comparator x y)))) 'whatever)))) (lambda (op) (lambda (x y) (if (if (flonum? x) (rational? y) #f) (op x (exact->inexact y)) (if (if (rational? x) (flonum? y) #f) (op (exact->inexact x) y) (op x y))))))


; ApplicTP


;Start of sub expr 
;(lambda (op) (lambda (x y) (if (if (flonum? x) (rational? y) #f) (op x (exact->inexact y)) (if (if (rational? x) (flonum? y) #f) (op (exact->inexact x) y) (op x y)))))

MALLOC rbx, (1+1)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 1
loop151:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop151    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop152:
cmp rcx, r8
je end_loop152
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop152
end_loop152:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode150)
jmp Lcont150
Lcode150:
push rbp
mov rbp,rsp

;Start of sub expr 
;(lambda (x y) (if (if (flonum? x) (rational? y) #f) (op x (exact->inexact y)) (if (if (rational? x) (flonum? y) #f) (op (exact->inexact x) y) (op x y))))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop154:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop154    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop155:
cmp rcx, r8
je end_loop155
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop155
end_loop155:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode153)
jmp Lcont153
Lcode153:
push rbp
mov rbp,rsp

;Start of sub expr 
;(if (if (flonum? x) (rational? y) #f) (op x (exact->inexact y)) (if (if (rational? x) (flonum? y) #f) (op (exact->inexact x) y) (op x y)))



;Start of sub expr 
;(if (flonum? x) (rational? y) #f)



;Start of sub expr 
;(flonum? x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg156
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg156:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse158

;Start of sub expr 
;(rational? y)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg157
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg157:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
jmp Lexit158
Lelse158:
mov rax, const_tbl+2

Lexit158:

cmp rax, SOB_FALSE_ADDRESS
je Lelse168

;Start of sub expr 
;(op x (exact->inexact y))


; ApplicTP


;Start of sub expr 
;(exact->inexact y)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*2]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg159
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg159:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (exact->inexact y)
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP160
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP160:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

jmp Lexit168
Lelse168:

;Start of sub expr 
;(if (if (rational? x) (flonum? y) #f) (op (exact->inexact x) y) (op x y))



;Start of sub expr 
;(if (rational? x) (flonum? y) #f)



;Start of sub expr 
;(rational? x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg161
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg161:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse163

;Start of sub expr 
;(flonum? y)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg162
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg162:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
jmp Lexit163
Lelse163:
mov rax, const_tbl+2

Lexit163:

cmp rax, SOB_FALSE_ADDRESS
je Lelse167

;Start of sub expr 
;(op (exact->inexact x) y)


; ApplicTP

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y

;Start of sub expr 
;(exact->inexact x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*2]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg164
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg164:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (exact->inexact x)
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP165
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP165:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

jmp Lexit167
Lelse167:

;Start of sub expr 
;(op x y)


; ApplicTP

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP166
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP166:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

Lexit167:

Lexit168:

leave
ret
Lcont153:


leave
ret
Lcont150:


push rax
;pushed arg (lambda (op) (lambda (x y) (if (if (flonum? x) (rational? y) #f) (op x (exact->inexact y)) (if (if (rational? x) (flonum? y) #f) (op (exact->inexact x) y) (op x y)))))
push 1  ; number of args

;Start of sub expr 
;(lambda (^numeric-op-dispatcher) (set! + (lambda x (fold-left (^numeric-op-dispatcher _+) 0 x))) (set! * (lambda x (fold-left (^numeric-op-dispatcher _*) 1 x))) (set! / ((lambda (/) (lambda (x . y) (if (null? y) (/ 1 x) (fold-left / x y)))) (^numeric-op-dispatcher _/))) ((lambda (^comparator) (set! = (^comparator (^numeric-op-dispatcher _=))) (set! < (^comparator (^numeric-op-dispatcher _<)))) (lambda (op) ((lambda (comparator) (set! comparator (box comparator)) (begin (set! comparator (lambda (x ys) (or (null? ys) (if (op x (car ys)) (comparator (car ys) (cdr ys)) #f)))) (lambda (x . y) (comparator x y)))) 'whatever))))

MALLOC rbx, (1+1)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 1
loop171:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop171    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop172:
cmp rcx, r8
je end_loop172
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop172
end_loop172:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode170)
jmp Lcont170
Lcode170:
push rbp
mov rbp,rsp

;Start of sub expr 
;(lambda x (fold-left (^numeric-op-dispatcher _+) 0 x))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop174:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop174    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop175:
cmp rcx, r8
je end_loop175
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop175
end_loop175:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode173)
jmp Lcont173
Lcode173:
Start_fix_stack180:   
        mov r8, qword [rsp + 8*2]     ; r8 = params number in stack (=real number)
        
        ; for each optional argument in stack (r8 - params_count) append to list
        cmp r8, 0  ; if equals, add nil and inc argc
        je shift_down_n_add_nil181 
        
        ; else, must loop to append all extra elements and decrease stack size
        sub r8, 0  ; r8 = |only optional args|
        lea r9, [rsp + (WORD_SIZE * 2)]   ; r9 points to argc
        mov r10, [r9]                     ; r10 = argc
        shl r10, 3                        ; argc in bytes
        add r9, r10                       ; r9 points to the last optional argument on stack

        push r9                           ; store the last arg address

        ; we'll now loop and append from last to first all optional arguments
        mov rcx, r8                 ; loop counter = PARAM_COUNT - 'regular params'
        mov r12, SOB_NIL_ADDRESS    ; NIL is the init var
        start_create_nested_pairs178:
        cmp rcx, 0
        je exit_create_nested_pairs178 

        mov r10, qword [r9]         ; get the curr opt arg
        MAKE_PAIR(r11, r10, r12)    ; r11 = Pair(r10, r12)
        mov r12, r11                ; r12 is the pair to return = acc

        sub r9, WORD_SIZE           ; point to the next (=below) arg
        dec rcx
        jmp start_create_nested_pairs178

        exit_create_nested_pairs178:

        pop r9                      ; address of A_n-1
        mov qword [r9], r12         ; put there the list we built                          
        
        ; fix argc (= regular params + 1 )
        mov r15, 0 
        inc r15
        mov qword [rsp + 2*WORD_SIZE], r15

        mov rcx, 2                            ; (ret, env, n) => (0,1,2)
        add rcx, 0             ; loop counter, rcx = 2 + regular params
        sub r9, WORD_SIZE                     ; r9 is the curr cell to occupy

        ; loop to fix frame
        fix_frame179:
        mov r11, rcx
        shl r11, 3                            ; r11 = WORD_SIZE*r11
        mov r12, [rsp + r11]                  ; r12 is the the value we want to move
        mov qword [r9], r12                  ; move it to the next cell to occupy

        cmp rcx, 0
        je fix_stack_pointers182
        ; else update counters and continue
        sub r9, WORD_SIZE                    ; update r9: next cell to occupy
        dec rcx
        jmp fix_frame179
        
      shift_down_n_add_nil181:
        ; shift one cell down = enlarge frame (updates rsp as well)
        INC_FRAME
        jmp Exit_fix_stack180
        
      fix_stack_pointers182:

      mov rsp, r9
      Exit_fix_stack180:

      
      
      push rbp
mov rbp,rsp

;Start of sub expr 
;(fold-left (^numeric-op-dispatcher _+) 0 x)


; ApplicTP

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
mov rax, const_tbl+34

push rax
;pushed arg 0

;Start of sub expr 
;(^numeric-op-dispatcher _+)


; Applic

mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*5]		;rax<-rib (=minor)

push rax
;pushed arg _+
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg176
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg176:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (^numeric-op-dispatcher _+)
push 3  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*3]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP177
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP177:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 3
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont173:

mov qword [fvar_tbl+8],rax
mov rax, SOB_VOID_ADDRESS


;Start of sub expr 
;(lambda x (fold-left (^numeric-op-dispatcher _*) 1 x))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop184:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop184    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop185:
cmp rcx, r8
je end_loop185
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop185
end_loop185:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode183)
jmp Lcont183
Lcode183:
Start_fix_stack190:   
        mov r8, qword [rsp + 8*2]     ; r8 = params number in stack (=real number)
        
        ; for each optional argument in stack (r8 - params_count) append to list
        cmp r8, 0  ; if equals, add nil and inc argc
        je shift_down_n_add_nil191 
        
        ; else, must loop to append all extra elements and decrease stack size
        sub r8, 0  ; r8 = |only optional args|
        lea r9, [rsp + (WORD_SIZE * 2)]   ; r9 points to argc
        mov r10, [r9]                     ; r10 = argc
        shl r10, 3                        ; argc in bytes
        add r9, r10                       ; r9 points to the last optional argument on stack

        push r9                           ; store the last arg address

        ; we'll now loop and append from last to first all optional arguments
        mov rcx, r8                 ; loop counter = PARAM_COUNT - 'regular params'
        mov r12, SOB_NIL_ADDRESS    ; NIL is the init var
        start_create_nested_pairs188:
        cmp rcx, 0
        je exit_create_nested_pairs188 

        mov r10, qword [r9]         ; get the curr opt arg
        MAKE_PAIR(r11, r10, r12)    ; r11 = Pair(r10, r12)
        mov r12, r11                ; r12 is the pair to return = acc

        sub r9, WORD_SIZE           ; point to the next (=below) arg
        dec rcx
        jmp start_create_nested_pairs188

        exit_create_nested_pairs188:

        pop r9                      ; address of A_n-1
        mov qword [r9], r12         ; put there the list we built                          
        
        ; fix argc (= regular params + 1 )
        mov r15, 0 
        inc r15
        mov qword [rsp + 2*WORD_SIZE], r15

        mov rcx, 2                            ; (ret, env, n) => (0,1,2)
        add rcx, 0             ; loop counter, rcx = 2 + regular params
        sub r9, WORD_SIZE                     ; r9 is the curr cell to occupy

        ; loop to fix frame
        fix_frame189:
        mov r11, rcx
        shl r11, 3                            ; r11 = WORD_SIZE*r11
        mov r12, [rsp + r11]                  ; r12 is the the value we want to move
        mov qword [r9], r12                  ; move it to the next cell to occupy

        cmp rcx, 0
        je fix_stack_pointers192
        ; else update counters and continue
        sub r9, WORD_SIZE                    ; update r9: next cell to occupy
        dec rcx
        jmp fix_frame189
        
      shift_down_n_add_nil191:
        ; shift one cell down = enlarge frame (updates rsp as well)
        INC_FRAME
        jmp Exit_fix_stack190
        
      fix_stack_pointers192:

      mov rsp, r9
      Exit_fix_stack190:

      
      
      push rbp
mov rbp,rsp

;Start of sub expr 
;(fold-left (^numeric-op-dispatcher _*) 1 x)


; ApplicTP

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
mov rax, const_tbl+51

push rax
;pushed arg 1

;Start of sub expr 
;(^numeric-op-dispatcher _*)


; Applic

mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*6]		;rax<-rib (=minor)

push rax
;pushed arg _*
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg186
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg186:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (^numeric-op-dispatcher _*)
push 3  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*3]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP187
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP187:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 3
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont183:

mov qword [fvar_tbl+0],rax
mov rax, SOB_VOID_ADDRESS


;Start of sub expr 
;((lambda (/) (lambda (x . y) (if (null? y) (/ 1 x) (fold-left / x y)))) (^numeric-op-dispatcher _/))


; Applic


;Start of sub expr 
;(^numeric-op-dispatcher _/)


; Applic

mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*7]		;rax<-rib (=minor)

push rax
;pushed arg _/
push 1  ; number of args
mov rax, qword [rbp + 8 * (4 + 0)]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg193
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg193:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (^numeric-op-dispatcher _/)
push 1  ; number of args

;Start of sub expr 
;(lambda (/) (lambda (x . y) (if (null? y) (/ 1 x) (fold-left / x y))))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop196:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop196    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop197:
cmp rcx, r8
je end_loop197
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop197
end_loop197:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode195)
jmp Lcont195
Lcode195:
push rbp
mov rbp,rsp

;Start of sub expr 
;(lambda (x . y) (if (null? y) (/ 1 x) (fold-left / x y)))

MALLOC rbx, (1+3)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 3
loop199:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop199    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop200:
cmp rcx, r8
je end_loop200
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop200
end_loop200:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode198)
jmp Lcont198
Lcode198:
Start_fix_stack207:   
        mov r8, qword [rsp + 8*2]     ; r8 = params number in stack (=real number)
        
        ; for each optional argument in stack (r8 - params_count) append to list
        cmp r8, 1  ; if equals, add nil and inc argc
        je shift_down_n_add_nil208 
        
        ; else, must loop to append all extra elements and decrease stack size
        sub r8, 1  ; r8 = |only optional args|
        lea r9, [rsp + (WORD_SIZE * 2)]   ; r9 points to argc
        mov r10, [r9]                     ; r10 = argc
        shl r10, 3                        ; argc in bytes
        add r9, r10                       ; r9 points to the last optional argument on stack

        push r9                           ; store the last arg address

        ; we'll now loop and append from last to first all optional arguments
        mov rcx, r8                 ; loop counter = PARAM_COUNT - 'regular params'
        mov r12, SOB_NIL_ADDRESS    ; NIL is the init var
        start_create_nested_pairs205:
        cmp rcx, 0
        je exit_create_nested_pairs205 

        mov r10, qword [r9]         ; get the curr opt arg
        MAKE_PAIR(r11, r10, r12)    ; r11 = Pair(r10, r12)
        mov r12, r11                ; r12 is the pair to return = acc

        sub r9, WORD_SIZE           ; point to the next (=below) arg
        dec rcx
        jmp start_create_nested_pairs205

        exit_create_nested_pairs205:

        pop r9                      ; address of A_n-1
        mov qword [r9], r12         ; put there the list we built                          
        
        ; fix argc (= regular params + 1 )
        mov r15, 1 
        inc r15
        mov qword [rsp + 2*WORD_SIZE], r15

        mov rcx, 2                            ; (ret, env, n) => (0,1,2)
        add rcx, 1             ; loop counter, rcx = 2 + regular params
        sub r9, WORD_SIZE                     ; r9 is the curr cell to occupy

        ; loop to fix frame
        fix_frame206:
        mov r11, rcx
        shl r11, 3                            ; r11 = WORD_SIZE*r11
        mov r12, [rsp + r11]                  ; r12 is the the value we want to move
        mov qword [r9], r12                  ; move it to the next cell to occupy

        cmp rcx, 0
        je fix_stack_pointers209
        ; else update counters and continue
        sub r9, WORD_SIZE                    ; update r9: next cell to occupy
        dec rcx
        jmp fix_frame206
        
      shift_down_n_add_nil208:
        ; shift one cell down = enlarge frame (updates rsp as well)
        INC_FRAME
        jmp Exit_fix_stack207
        
      fix_stack_pointers209:

      mov rsp, r9
      Exit_fix_stack207:

      
      
      push rbp
mov rbp,rsp

;Start of sub expr 
;(if (null? y) (/ 1 x) (fold-left / x y))



;Start of sub expr 
;(null? y)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*2]		;rax<-rib (=major)
mov rax,qword[rax+8*12]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg201
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg201:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse204

;Start of sub expr 
;(/ 1 x)


; ApplicTP

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
mov rax, const_tbl+51

push rax
;pushed arg 1
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP202
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP202:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

jmp Lexit204
Lelse204:

;Start of sub expr 
;(fold-left / x y)


; ApplicTP

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)

push rax
;pushed arg /
push 3  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*2]		;rax<-rib (=major)
mov rax,qword[rax+8*3]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP203
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP203:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 3
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

Lexit204:

leave
ret
Lcont198:


leave
ret
Lcont195:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg194
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg194:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          mov qword [fvar_tbl+24],rax
mov rax, SOB_VOID_ADDRESS


;Start of sub expr 
;((lambda (^comparator) (set! = (^comparator (^numeric-op-dispatcher _=))) (set! < (^comparator (^numeric-op-dispatcher _<)))) (lambda (op) ((lambda (comparator) (set! comparator (box comparator)) (begin (set! comparator (lambda (x ys) (or (null? ys) (if (op x (car ys)) (comparator (car ys) (cdr ys)) #f)))) (lambda (x . y) (comparator x y)))) 'whatever)))


; ApplicTP


;Start of sub expr 
;(lambda (op) ((lambda (comparator) (set! comparator (box comparator)) (begin (set! comparator (lambda (x ys) (or (null? ys) (if (op x (car ys)) (comparator (car ys) (cdr ys)) #f)))) (lambda (x . y) (comparator x y)))) 'whatever))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop211:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop211    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop212:
cmp rcx, r8
je end_loop212
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop212
end_loop212:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode210)
jmp Lcont210
Lcode210:
push rbp
mov rbp,rsp

;Start of sub expr 
;((lambda (comparator) (set! comparator (box comparator)) (begin (set! comparator (lambda (x ys) (or (null? ys) (if (op x (car ys)) (comparator (car ys) (cdr ys)) #f)))) (lambda (x . y) (comparator x y)))) 'whatever)


; ApplicTP

mov rax, const_tbl+23

push rax
;pushed arg 'whatever
push 1  ; number of args

;Start of sub expr 
;(lambda (comparator) (set! comparator (box comparator)) (begin (set! comparator (lambda (x ys) (or (null? ys) (if (op x (car ys)) (comparator (car ys) (cdr ys)) #f)))) (lambda (x . y) (comparator x y))))

MALLOC rbx, (1+3)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 3
loop215:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop215    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop216:
cmp rcx, r8
je end_loop216
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop216
end_loop216:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode214)
jmp Lcont214
Lcode214:
push rbp
mov rbp,rsp
MALLOC rcx, 8*1   ;allocate memory to box param
mov rax, qword [rbp + 8 * (4 + 0)]
mov [rcx], qword rax
mov rax, rcx
mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS


;Start of sub expr 
;(lambda (x ys) (or (null? ys) (if (op x (car ys)) (comparator (car ys) (cdr ys)) #f)))

MALLOC rbx, (1+4)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 4
loop218:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop218    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop219:
cmp rcx, r8
je end_loop219
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop219
end_loop219:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode217)
jmp Lcont217
Lcode217:
push rbp
mov rbp,rsp

;Start of sub expr 
;(null? ys)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg ys
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*3]		;rax<-rib (=major)
mov rax,qword[rax+8*12]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg220
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg220:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          cmp rax, SOB_FALSE_ADDRESS
jne Lexit227

;Start of sub expr 
;(if (op x (car ys)) (comparator (car ys) (cdr ys)) #f)



;Start of sub expr 
;(op x (car ys))


; Applic


;Start of sub expr 
;(car ys)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg ys
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*3]		;rax<-rib (=major)
mov rax,qword[rax+8*10]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg221
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg221:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (car ys)
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg222
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg222:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse226

;Start of sub expr 
;(comparator (car ys) (cdr ys))


; ApplicTP


;Start of sub expr 
;(cdr ys)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg ys
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*3]		;rax<-rib (=major)
mov rax,qword[rax+8*11]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg223
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg223:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (cdr ys)

;Start of sub expr 
;(car ys)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg ys
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*3]		;rax<-rib (=major)
mov rax,qword[rax+8*10]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg224
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg224:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (car ys)
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)
mov rax, qword [rax]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP225
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP225:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

jmp Lexit226
Lelse226:
mov rax, const_tbl+2

Lexit226:
Lexit227:

leave
ret
Lcont217:

push rax
mov rax, qword [rbp + 8 * (4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS


;Start of sub expr 
;(lambda (x . y) (comparator x y))

MALLOC rbx, (1+4)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 4
loop229:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop229    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop230:
cmp rcx, r8
je end_loop230
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop230
end_loop230:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode228)
jmp Lcont228
Lcode228:
Start_fix_stack234:   
        mov r8, qword [rsp + 8*2]     ; r8 = params number in stack (=real number)
        
        ; for each optional argument in stack (r8 - params_count) append to list
        cmp r8, 1  ; if equals, add nil and inc argc
        je shift_down_n_add_nil235 
        
        ; else, must loop to append all extra elements and decrease stack size
        sub r8, 1  ; r8 = |only optional args|
        lea r9, [rsp + (WORD_SIZE * 2)]   ; r9 points to argc
        mov r10, [r9]                     ; r10 = argc
        shl r10, 3                        ; argc in bytes
        add r9, r10                       ; r9 points to the last optional argument on stack

        push r9                           ; store the last arg address

        ; we'll now loop and append from last to first all optional arguments
        mov rcx, r8                 ; loop counter = PARAM_COUNT - 'regular params'
        mov r12, SOB_NIL_ADDRESS    ; NIL is the init var
        start_create_nested_pairs232:
        cmp rcx, 0
        je exit_create_nested_pairs232 

        mov r10, qword [r9]         ; get the curr opt arg
        MAKE_PAIR(r11, r10, r12)    ; r11 = Pair(r10, r12)
        mov r12, r11                ; r12 is the pair to return = acc

        sub r9, WORD_SIZE           ; point to the next (=below) arg
        dec rcx
        jmp start_create_nested_pairs232

        exit_create_nested_pairs232:

        pop r9                      ; address of A_n-1
        mov qword [r9], r12         ; put there the list we built                          
        
        ; fix argc (= regular params + 1 )
        mov r15, 1 
        inc r15
        mov qword [rsp + 2*WORD_SIZE], r15

        mov rcx, 2                            ; (ret, env, n) => (0,1,2)
        add rcx, 1             ; loop counter, rcx = 2 + regular params
        sub r9, WORD_SIZE                     ; r9 is the curr cell to occupy

        ; loop to fix frame
        fix_frame233:
        mov r11, rcx
        shl r11, 3                            ; r11 = WORD_SIZE*r11
        mov r12, [rsp + r11]                  ; r12 is the the value we want to move
        mov qword [r9], r12                  ; move it to the next cell to occupy

        cmp rcx, 0
        je fix_stack_pointers236
        ; else update counters and continue
        sub r9, WORD_SIZE                    ; update r9: next cell to occupy
        dec rcx
        jmp fix_frame233
        
      shift_down_n_add_nil235:
        ; shift one cell down = enlarge frame (updates rsp as well)
        INC_FRAME
        jmp Exit_fix_stack234
        
      fix_stack_pointers236:

      mov rsp, r9
      Exit_fix_stack234:

      
      
      push rbp
mov rbp,rsp

;Start of sub expr 
;(comparator x y)


; ApplicTP

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)
mov rax, qword [rax]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP231
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP231:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont228:




leave
ret
Lcont214:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP213
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP213:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 1
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont210:


push rax
;pushed arg (lambda (op) ((lambda (comparator) (set! comparator (box comparator)) (begin (set! comparator (lambda (x ys) (or (null? ys) (if (op x (car ys)) (comparator (car ys) (cdr ys)) #f)))) (lambda (x . y) (comparator x y)))) 'whatever))
push 1  ; number of args

;Start of sub expr 
;(lambda (^comparator) (set! = (^comparator (^numeric-op-dispatcher _=))) (set! < (^comparator (^numeric-op-dispatcher _<))))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop239:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop239    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop240:
cmp rcx, r8
je end_loop240
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop240
end_loop240:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode238)
jmp Lcont238
Lcode238:
push rbp
mov rbp,rsp

;Start of sub expr 
;(^comparator (^numeric-op-dispatcher _=))


; Applic


;Start of sub expr 
;(^numeric-op-dispatcher _=)


; Applic

mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*8]		;rax<-rib (=minor)

push rax
;pushed arg _=
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg241
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg241:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (^numeric-op-dispatcher _=)
push 1  ; number of args
mov rax, qword [rbp + 8 * (4 + 0)]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg242
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg242:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          mov qword [fvar_tbl+40],rax
mov rax, SOB_VOID_ADDRESS


;Start of sub expr 
;(^comparator (^numeric-op-dispatcher _<))


; Applic


;Start of sub expr 
;(^numeric-op-dispatcher _<)


; Applic

mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*9]		;rax<-rib (=minor)

push rax
;pushed arg _<
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg243
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg243:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (^numeric-op-dispatcher _<)
push 1  ; number of args
mov rax, qword [rbp + 8 * (4 + 0)]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg244
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg244:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          mov qword [fvar_tbl+32],rax
mov rax, SOB_VOID_ADDRESS


leave
ret
Lcont238:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP237
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP237:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 1
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code


leave
ret
Lcont170:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP169
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP169:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 1
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont149:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg148
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg148:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
	call write_sob_if_not_void




;START OF CODE of (define - ((lambda (apply + null?) (lambda (x . y) (if (null? y) (+ 0 (* -1 x)) (+ x (* -1 (apply + y)))))) apply + null?))



;Start of sub expr 
;((lambda (apply + null?) (lambda (x . y) (if (null? y) (+ 0 (* -1 x)) (+ x (* -1 (apply + y)))))) apply + null?)


; Applic

mov rax, qword [fvar_tbl+256]

push rax
;pushed arg null?
mov rax, qword [fvar_tbl+8]

push rax
;pushed arg +
mov rax, qword [fvar_tbl+64]

push rax
;pushed arg apply
push 3  ; number of args

;Start of sub expr 
;(lambda (apply + null?) (lambda (x . y) (if (null? y) (+ 0 (* -1 x)) (+ x (* -1 (apply + y))))))

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode246)
jmp Lcont246
Lcode246:
push rbp
mov rbp,rsp

;Start of sub expr 
;(lambda (x . y) (if (null? y) (+ 0 (* -1 x)) (+ x (* -1 (apply + y)))))

MALLOC rbx, (1+1)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 1
loop248:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop248    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop249:
cmp rcx, r8
je end_loop249
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop249
end_loop249:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode247)
jmp Lcont247
Lcode247:
Start_fix_stack259:   
        mov r8, qword [rsp + 8*2]     ; r8 = params number in stack (=real number)
        
        ; for each optional argument in stack (r8 - params_count) append to list
        cmp r8, 1  ; if equals, add nil and inc argc
        je shift_down_n_add_nil260 
        
        ; else, must loop to append all extra elements and decrease stack size
        sub r8, 1  ; r8 = |only optional args|
        lea r9, [rsp + (WORD_SIZE * 2)]   ; r9 points to argc
        mov r10, [r9]                     ; r10 = argc
        shl r10, 3                        ; argc in bytes
        add r9, r10                       ; r9 points to the last optional argument on stack

        push r9                           ; store the last arg address

        ; we'll now loop and append from last to first all optional arguments
        mov rcx, r8                 ; loop counter = PARAM_COUNT - 'regular params'
        mov r12, SOB_NIL_ADDRESS    ; NIL is the init var
        start_create_nested_pairs257:
        cmp rcx, 0
        je exit_create_nested_pairs257 

        mov r10, qword [r9]         ; get the curr opt arg
        MAKE_PAIR(r11, r10, r12)    ; r11 = Pair(r10, r12)
        mov r12, r11                ; r12 is the pair to return = acc

        sub r9, WORD_SIZE           ; point to the next (=below) arg
        dec rcx
        jmp start_create_nested_pairs257

        exit_create_nested_pairs257:

        pop r9                      ; address of A_n-1
        mov qword [r9], r12         ; put there the list we built                          
        
        ; fix argc (= regular params + 1 )
        mov r15, 1 
        inc r15
        mov qword [rsp + 2*WORD_SIZE], r15

        mov rcx, 2                            ; (ret, env, n) => (0,1,2)
        add rcx, 1             ; loop counter, rcx = 2 + regular params
        sub r9, WORD_SIZE                     ; r9 is the curr cell to occupy

        ; loop to fix frame
        fix_frame258:
        mov r11, rcx
        shl r11, 3                            ; r11 = WORD_SIZE*r11
        mov r12, [rsp + r11]                  ; r12 is the the value we want to move
        mov qword [r9], r12                  ; move it to the next cell to occupy

        cmp rcx, 0
        je fix_stack_pointers261
        ; else update counters and continue
        sub r9, WORD_SIZE                    ; update r9: next cell to occupy
        dec rcx
        jmp fix_frame258
        
      shift_down_n_add_nil260:
        ; shift one cell down = enlarge frame (updates rsp as well)
        INC_FRAME
        jmp Exit_fix_stack259
        
      fix_stack_pointers261:

      mov rsp, r9
      Exit_fix_stack259:

      
      
      push rbp
mov rbp,rsp

;Start of sub expr 
;(if (null? y) (+ 0 (* -1 x)) (+ x (* -1 (apply + y))))



;Start of sub expr 
;(null? y)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*2]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg250
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg250:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse256

;Start of sub expr 
;(+ 0 (* -1 x))


; ApplicTP


;Start of sub expr 
;(* -1 x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
mov rax, const_tbl+68

push rax
;pushed arg -1
push 2  ; number of args
mov rax, qword [fvar_tbl+0]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg251
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg251:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (* -1 x)
mov rax, const_tbl+34

push rax
;pushed arg 0
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP252
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP252:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

jmp Lexit256
Lelse256:

;Start of sub expr 
;(+ x (* -1 (apply + y)))


; ApplicTP


;Start of sub expr 
;(* -1 (apply + y))


; Applic


;Start of sub expr 
;(apply + y)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)

push rax
;pushed arg +
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg253
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg253:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (apply + y)
mov rax, const_tbl+68

push rax
;pushed arg -1
push 2  ; number of args
mov rax, qword [fvar_tbl+0]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg254
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg254:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (* -1 (apply + y))
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP255
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP255:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

Lexit256:

leave
ret
Lcont247:


leave
ret
Lcont246:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg245
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg245:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          mov qword [fvar_tbl+16],rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void




;START OF CODE of (define > ((lambda (null? not car cdr < =) ((lambda (>-loop) (set! >-loop (box >-loop)) (begin (set! >-loop (lambda (x ys) (or (null? ys) (if (not (< x (car ys))) (if (not (= x (car ys))) (>-loop (car ys) (cdr ys)) #f) #f)))) (lambda (x . y) (>-loop x y)))) 'whatever)) null? not car cdr < =))



;Start of sub expr 
;((lambda (null? not car cdr < =) ((lambda (>-loop) (set! >-loop (box >-loop)) (begin (set! >-loop (lambda (x ys) (or (null? ys) (if (not (< x (car ys))) (if (not (= x (car ys))) (>-loop (car ys) (cdr ys)) #f) #f)))) (lambda (x . y) (>-loop x y)))) 'whatever)) null? not car cdr < =)


; Applic

mov rax, qword [fvar_tbl+40]

push rax
;pushed arg =
mov rax, qword [fvar_tbl+32]

push rax
;pushed arg <
mov rax, qword [fvar_tbl+88]

push rax
;pushed arg cdr
mov rax, qword [fvar_tbl+80]

push rax
;pushed arg car
mov rax, qword [fvar_tbl+248]

push rax
;pushed arg not
mov rax, qword [fvar_tbl+256]

push rax
;pushed arg null?
push 6  ; number of args

;Start of sub expr 
;(lambda (null? not car cdr < =) ((lambda (>-loop) (set! >-loop (box >-loop)) (begin (set! >-loop (lambda (x ys) (or (null? ys) (if (not (< x (car ys))) (if (not (= x (car ys))) (>-loop (car ys) (cdr ys)) #f) #f)))) (lambda (x . y) (>-loop x y)))) 'whatever))

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode263)
jmp Lcont263
Lcode263:
push rbp
mov rbp,rsp

;Start of sub expr 
;((lambda (>-loop) (set! >-loop (box >-loop)) (begin (set! >-loop (lambda (x ys) (or (null? ys) (if (not (< x (car ys))) (if (not (= x (car ys))) (>-loop (car ys) (cdr ys)) #f) #f)))) (lambda (x . y) (>-loop x y)))) 'whatever)


; ApplicTP

mov rax, const_tbl+23

push rax
;pushed arg 'whatever
push 1  ; number of args

;Start of sub expr 
;(lambda (>-loop) (set! >-loop (box >-loop)) (begin (set! >-loop (lambda (x ys) (or (null? ys) (if (not (< x (car ys))) (if (not (= x (car ys))) (>-loop (car ys) (cdr ys)) #f) #f)))) (lambda (x . y) (>-loop x y))))

MALLOC rbx, (1+1)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 1
loop266:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop266    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop267:
cmp rcx, r8
je end_loop267
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop267
end_loop267:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode265)
jmp Lcont265
Lcode265:
push rbp
mov rbp,rsp
MALLOC rcx, 8*1   ;allocate memory to box param
mov rax, qword [rbp + 8 * (4 + 0)]
mov [rcx], qword rax
mov rax, rcx
mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS


;Start of sub expr 
;(lambda (x ys) (or (null? ys) (if (not (< x (car ys))) (if (not (= x (car ys))) (>-loop (car ys) (cdr ys)) #f) #f)))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop269:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop269    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop270:
cmp rcx, r8
je end_loop270
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop270
end_loop270:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode268)
jmp Lcont268
Lcode268:
push rbp
mov rbp,rsp

;Start of sub expr 
;(null? ys)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg ys
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg271
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg271:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          cmp rax, SOB_FALSE_ADDRESS
jne Lexit283

;Start of sub expr 
;(if (not (< x (car ys))) (if (not (= x (car ys))) (>-loop (car ys) (cdr ys)) #f) #f)



;Start of sub expr 
;(not (< x (car ys)))


; Applic


;Start of sub expr 
;(< x (car ys))


; Applic


;Start of sub expr 
;(car ys)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg ys
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*2]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg272
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg272:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (car ys)
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*4]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg273
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg273:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (< x (car ys))
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg274
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg274:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse282

;Start of sub expr 
;(if (not (= x (car ys))) (>-loop (car ys) (cdr ys)) #f)



;Start of sub expr 
;(not (= x (car ys)))


; Applic


;Start of sub expr 
;(= x (car ys))


; Applic


;Start of sub expr 
;(car ys)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg ys
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*2]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg275
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg275:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (car ys)
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*5]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg276
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg276:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (= x (car ys))
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg277
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg277:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse281

;Start of sub expr 
;(>-loop (car ys) (cdr ys))


; ApplicTP


;Start of sub expr 
;(cdr ys)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg ys
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*3]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg278
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg278:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (cdr ys)

;Start of sub expr 
;(car ys)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg ys
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*2]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg279
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg279:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (car ys)
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)
mov rax, qword [rax]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP280
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP280:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

jmp Lexit281
Lelse281:
mov rax, const_tbl+2

Lexit281:

jmp Lexit282
Lelse282:
mov rax, const_tbl+2

Lexit282:
Lexit283:

leave
ret
Lcont268:

push rax
mov rax, qword [rbp + 8 * (4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS


;Start of sub expr 
;(lambda (x . y) (>-loop x y))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop285:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop285    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop286:
cmp rcx, r8
je end_loop286
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop286
end_loop286:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode284)
jmp Lcont284
Lcode284:
Start_fix_stack290:   
        mov r8, qword [rsp + 8*2]     ; r8 = params number in stack (=real number)
        
        ; for each optional argument in stack (r8 - params_count) append to list
        cmp r8, 1  ; if equals, add nil and inc argc
        je shift_down_n_add_nil291 
        
        ; else, must loop to append all extra elements and decrease stack size
        sub r8, 1  ; r8 = |only optional args|
        lea r9, [rsp + (WORD_SIZE * 2)]   ; r9 points to argc
        mov r10, [r9]                     ; r10 = argc
        shl r10, 3                        ; argc in bytes
        add r9, r10                       ; r9 points to the last optional argument on stack

        push r9                           ; store the last arg address

        ; we'll now loop and append from last to first all optional arguments
        mov rcx, r8                 ; loop counter = PARAM_COUNT - 'regular params'
        mov r12, SOB_NIL_ADDRESS    ; NIL is the init var
        start_create_nested_pairs288:
        cmp rcx, 0
        je exit_create_nested_pairs288 

        mov r10, qword [r9]         ; get the curr opt arg
        MAKE_PAIR(r11, r10, r12)    ; r11 = Pair(r10, r12)
        mov r12, r11                ; r12 is the pair to return = acc

        sub r9, WORD_SIZE           ; point to the next (=below) arg
        dec rcx
        jmp start_create_nested_pairs288

        exit_create_nested_pairs288:

        pop r9                      ; address of A_n-1
        mov qword [r9], r12         ; put there the list we built                          
        
        ; fix argc (= regular params + 1 )
        mov r15, 1 
        inc r15
        mov qword [rsp + 2*WORD_SIZE], r15

        mov rcx, 2                            ; (ret, env, n) => (0,1,2)
        add rcx, 1             ; loop counter, rcx = 2 + regular params
        sub r9, WORD_SIZE                     ; r9 is the curr cell to occupy

        ; loop to fix frame
        fix_frame289:
        mov r11, rcx
        shl r11, 3                            ; r11 = WORD_SIZE*r11
        mov r12, [rsp + r11]                  ; r12 is the the value we want to move
        mov qword [r9], r12                  ; move it to the next cell to occupy

        cmp rcx, 0
        je fix_stack_pointers292
        ; else update counters and continue
        sub r9, WORD_SIZE                    ; update r9: next cell to occupy
        dec rcx
        jmp fix_frame289
        
      shift_down_n_add_nil291:
        ; shift one cell down = enlarge frame (updates rsp as well)
        INC_FRAME
        jmp Exit_fix_stack290
        
      fix_stack_pointers292:

      mov rsp, r9
      Exit_fix_stack290:

      
      
      push rbp
mov rbp,rsp

;Start of sub expr 
;(>-loop x y)


; ApplicTP

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)
mov rax, qword [rax]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP287
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP287:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont284:




leave
ret
Lcont265:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP264
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP264:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 1
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont263:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg262
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg262:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          mov qword [fvar_tbl+48],rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void




;START OF CODE of (define gcd ((lambda (gcd null? car cdr) ((lambda (gcd-loop) (set! gcd-loop (box gcd-loop)) (begin (set! gcd-loop (lambda (x ys) (if (null? ys) x (gcd-loop (gcd x (car ys)) (cdr ys))))) (lambda x (if (null? x) 0 (gcd-loop (car x) (cdr x)))))) 'whatever)) gcd null? car cdr))



;Start of sub expr 
;((lambda (gcd null? car cdr) ((lambda (gcd-loop) (set! gcd-loop (box gcd-loop)) (begin (set! gcd-loop (lambda (x ys) (if (null? ys) x (gcd-loop (gcd x (car ys)) (cdr ys))))) (lambda x (if (null? x) 0 (gcd-loop (car x) (cdr x)))))) 'whatever)) gcd null? car cdr)


; Applic

mov rax, qword [fvar_tbl+88]

push rax
;pushed arg cdr
mov rax, qword [fvar_tbl+80]

push rax
;pushed arg car
mov rax, qword [fvar_tbl+256]

push rax
;pushed arg null?
mov rax, qword [fvar_tbl+184]

push rax
;pushed arg gcd
push 4  ; number of args

;Start of sub expr 
;(lambda (gcd null? car cdr) ((lambda (gcd-loop) (set! gcd-loop (box gcd-loop)) (begin (set! gcd-loop (lambda (x ys) (if (null? ys) x (gcd-loop (gcd x (car ys)) (cdr ys))))) (lambda x (if (null? x) 0 (gcd-loop (car x) (cdr x)))))) 'whatever))

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode294)
jmp Lcont294
Lcode294:
push rbp
mov rbp,rsp

;Start of sub expr 
;((lambda (gcd-loop) (set! gcd-loop (box gcd-loop)) (begin (set! gcd-loop (lambda (x ys) (if (null? ys) x (gcd-loop (gcd x (car ys)) (cdr ys))))) (lambda x (if (null? x) 0 (gcd-loop (car x) (cdr x)))))) 'whatever)


; ApplicTP

mov rax, const_tbl+23

push rax
;pushed arg 'whatever
push 1  ; number of args

;Start of sub expr 
;(lambda (gcd-loop) (set! gcd-loop (box gcd-loop)) (begin (set! gcd-loop (lambda (x ys) (if (null? ys) x (gcd-loop (gcd x (car ys)) (cdr ys))))) (lambda x (if (null? x) 0 (gcd-loop (car x) (cdr x))))))

MALLOC rbx, (1+1)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 1
loop297:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop297    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop298:
cmp rcx, r8
je end_loop298
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop298
end_loop298:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode296)
jmp Lcont296
Lcode296:
push rbp
mov rbp,rsp
MALLOC rcx, 8*1   ;allocate memory to box param
mov rax, qword [rbp + 8 * (4 + 0)]
mov [rcx], qword rax
mov rax, rcx
mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS


;Start of sub expr 
;(lambda (x ys) (if (null? ys) x (gcd-loop (gcd x (car ys)) (cdr ys))))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop300:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop300    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop301:
cmp rcx, r8
je end_loop301
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop301
end_loop301:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode299)
jmp Lcont299
Lcode299:
push rbp
mov rbp,rsp

;Start of sub expr 
;(if (null? ys) x (gcd-loop (gcd x (car ys)) (cdr ys)))



;Start of sub expr 
;(null? ys)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg ys
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg302
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg302:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse307
mov rax, qword [rbp + 8 * (4 + 0)]

jmp Lexit307
Lelse307:

;Start of sub expr 
;(gcd-loop (gcd x (car ys)) (cdr ys))


; ApplicTP


;Start of sub expr 
;(cdr ys)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg ys
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*3]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg303
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg303:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (cdr ys)

;Start of sub expr 
;(gcd x (car ys))


; Applic


;Start of sub expr 
;(car ys)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg ys
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*2]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg304
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg304:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (car ys)
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg305
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg305:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (gcd x (car ys))
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)
mov rax, qword [rax]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP306
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP306:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

Lexit307:

leave
ret
Lcont299:

push rax
mov rax, qword [rbp + 8 * (4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS


;Start of sub expr 
;(lambda x (if (null? x) 0 (gcd-loop (car x) (cdr x))))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop309:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop309    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop310:
cmp rcx, r8
je end_loop310
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop310
end_loop310:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode308)
jmp Lcont308
Lcode308:
Start_fix_stack318:   
        mov r8, qword [rsp + 8*2]     ; r8 = params number in stack (=real number)
        
        ; for each optional argument in stack (r8 - params_count) append to list
        cmp r8, 0  ; if equals, add nil and inc argc
        je shift_down_n_add_nil319 
        
        ; else, must loop to append all extra elements and decrease stack size
        sub r8, 0  ; r8 = |only optional args|
        lea r9, [rsp + (WORD_SIZE * 2)]   ; r9 points to argc
        mov r10, [r9]                     ; r10 = argc
        shl r10, 3                        ; argc in bytes
        add r9, r10                       ; r9 points to the last optional argument on stack

        push r9                           ; store the last arg address

        ; we'll now loop and append from last to first all optional arguments
        mov rcx, r8                 ; loop counter = PARAM_COUNT - 'regular params'
        mov r12, SOB_NIL_ADDRESS    ; NIL is the init var
        start_create_nested_pairs316:
        cmp rcx, 0
        je exit_create_nested_pairs316 

        mov r10, qword [r9]         ; get the curr opt arg
        MAKE_PAIR(r11, r10, r12)    ; r11 = Pair(r10, r12)
        mov r12, r11                ; r12 is the pair to return = acc

        sub r9, WORD_SIZE           ; point to the next (=below) arg
        dec rcx
        jmp start_create_nested_pairs316

        exit_create_nested_pairs316:

        pop r9                      ; address of A_n-1
        mov qword [r9], r12         ; put there the list we built                          
        
        ; fix argc (= regular params + 1 )
        mov r15, 0 
        inc r15
        mov qword [rsp + 2*WORD_SIZE], r15

        mov rcx, 2                            ; (ret, env, n) => (0,1,2)
        add rcx, 0             ; loop counter, rcx = 2 + regular params
        sub r9, WORD_SIZE                     ; r9 is the curr cell to occupy

        ; loop to fix frame
        fix_frame317:
        mov r11, rcx
        shl r11, 3                            ; r11 = WORD_SIZE*r11
        mov r12, [rsp + r11]                  ; r12 is the the value we want to move
        mov qword [r9], r12                  ; move it to the next cell to occupy

        cmp rcx, 0
        je fix_stack_pointers320
        ; else update counters and continue
        sub r9, WORD_SIZE                    ; update r9: next cell to occupy
        dec rcx
        jmp fix_frame317
        
      shift_down_n_add_nil319:
        ; shift one cell down = enlarge frame (updates rsp as well)
        INC_FRAME
        jmp Exit_fix_stack318
        
      fix_stack_pointers320:

      mov rsp, r9
      Exit_fix_stack318:

      
      
      push rbp
mov rbp,rsp

;Start of sub expr 
;(if (null? x) 0 (gcd-loop (car x) (cdr x)))



;Start of sub expr 
;(null? x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg311
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg311:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse315
mov rax, const_tbl+34

jmp Lexit315
Lelse315:

;Start of sub expr 
;(gcd-loop (car x) (cdr x))


; ApplicTP


;Start of sub expr 
;(cdr x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*3]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg312
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg312:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (cdr x)

;Start of sub expr 
;(car x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*2]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg313
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg313:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (car x)
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)
mov rax, qword [rax]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP314
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP314:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

Lexit315:

leave
ret
Lcont308:




leave
ret
Lcont296:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP295
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP295:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 1
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont294:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg293
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg293:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          mov qword [fvar_tbl+184],rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void




;START OF CODE of (define zero? ((lambda (=) (lambda (x) (= x 0))) =))



;Start of sub expr 
;((lambda (=) (lambda (x) (= x 0))) =)


; Applic

mov rax, qword [fvar_tbl+40]

push rax
;pushed arg =
push 1  ; number of args

;Start of sub expr 
;(lambda (=) (lambda (x) (= x 0)))

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode322)
jmp Lcont322
Lcode322:
push rbp
mov rbp,rsp

;Start of sub expr 
;(lambda (x) (= x 0))

MALLOC rbx, (1+1)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 1
loop324:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop324    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop325:
cmp rcx, r8
je end_loop325
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop325
end_loop325:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode323)
jmp Lcont323
Lcode323:
push rbp
mov rbp,rsp

;Start of sub expr 
;(= x 0)


; ApplicTP

mov rax, const_tbl+34

push rax
;pushed arg 0
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP326
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP326:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont323:


leave
ret
Lcont322:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg321
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg321:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          mov qword [fvar_tbl+376],rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void




;START OF CODE of (define integer? ((lambda (rational? = denominator) (lambda (x) (if (rational? x) (= (denominator x) 1) #f))) rational? = denominator))



;Start of sub expr 
;((lambda (rational? = denominator) (lambda (x) (if (rational? x) (= (denominator x) 1) #f))) rational? = denominator)


; Applic

mov rax, qword [fvar_tbl+128]

push rax
;pushed arg denominator
mov rax, qword [fvar_tbl+40]

push rax
;pushed arg =
mov rax, qword [fvar_tbl+296]

push rax
;pushed arg rational?
push 3  ; number of args

;Start of sub expr 
;(lambda (rational? = denominator) (lambda (x) (if (rational? x) (= (denominator x) 1) #f)))

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode328)
jmp Lcont328
Lcode328:
push rbp
mov rbp,rsp

;Start of sub expr 
;(lambda (x) (if (rational? x) (= (denominator x) 1) #f))

MALLOC rbx, (1+1)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 1
loop330:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop330    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop331:
cmp rcx, r8
je end_loop331
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop331
end_loop331:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode329)
jmp Lcont329
Lcode329:
push rbp
mov rbp,rsp

;Start of sub expr 
;(if (rational? x) (= (denominator x) 1) #f)



;Start of sub expr 
;(rational? x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg332
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg332:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse335

;Start of sub expr 
;(= (denominator x) 1)


; ApplicTP

mov rax, const_tbl+51

push rax
;pushed arg 1

;Start of sub expr 
;(denominator x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*2]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg333
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg333:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (denominator x)
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP334
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP334:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

jmp Lexit335
Lelse335:
mov rax, const_tbl+2

Lexit335:

leave
ret
Lcont329:


leave
ret
Lcont328:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg327
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg327:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          mov qword [fvar_tbl+192],rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void




;START OF CODE of (define number? ((lambda (flonum? rational?) (lambda (x) (or (flonum? x) (rational? x)))) flonum? rational?))



;Start of sub expr 
;((lambda (flonum? rational?) (lambda (x) (or (flonum? x) (rational? x)))) flonum? rational?)


; Applic

mov rax, qword [fvar_tbl+296]

push rax
;pushed arg rational?
mov rax, qword [fvar_tbl+160]

push rax
;pushed arg flonum?
push 2  ; number of args

;Start of sub expr 
;(lambda (flonum? rational?) (lambda (x) (or (flonum? x) (rational? x))))

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode337)
jmp Lcont337
Lcode337:
push rbp
mov rbp,rsp

;Start of sub expr 
;(lambda (x) (or (flonum? x) (rational? x)))

MALLOC rbx, (1+1)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 1
loop339:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop339    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop340:
cmp rcx, r8
je end_loop340
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop340
end_loop340:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode338)
jmp Lcont338
Lcode338:
push rbp
mov rbp,rsp

;Start of sub expr 
;(flonum? x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg341
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg341:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          cmp rax, SOB_FALSE_ADDRESS
jne Lexit343

;Start of sub expr 
;(rational? x)


; ApplicTP

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP342
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP342:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 1
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code
Lexit343:

leave
ret
Lcont338:


leave
ret
Lcont337:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg336
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg336:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          mov qword [fvar_tbl+264],rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void




;START OF CODE of (define length ((lambda (fold-left +) (lambda (l) (fold-left (lambda (acc e) (+ acc 1)) 0 l))) fold-left +))



;Start of sub expr 
;((lambda (fold-left +) (lambda (l) (fold-left (lambda (acc e) (+ acc 1)) 0 l))) fold-left +)


; Applic

mov rax, qword [fvar_tbl+8]

push rax
;pushed arg +
mov rax, qword [fvar_tbl+168]

push rax
;pushed arg fold-left
push 2  ; number of args

;Start of sub expr 
;(lambda (fold-left +) (lambda (l) (fold-left (lambda (acc e) (+ acc 1)) 0 l)))

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode345)
jmp Lcont345
Lcode345:
push rbp
mov rbp,rsp

;Start of sub expr 
;(lambda (l) (fold-left (lambda (acc e) (+ acc 1)) 0 l))

MALLOC rbx, (1+1)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 1
loop347:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop347    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop348:
cmp rcx, r8
je end_loop348
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop348
end_loop348:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode346)
jmp Lcont346
Lcode346:
push rbp
mov rbp,rsp

;Start of sub expr 
;(fold-left (lambda (acc e) (+ acc 1)) 0 l)


; ApplicTP

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg l
mov rax, const_tbl+34

push rax
;pushed arg 0

;Start of sub expr 
;(lambda (acc e) (+ acc 1))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop350:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop350    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop351:
cmp rcx, r8
je end_loop351
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop351
end_loop351:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode349)
jmp Lcont349
Lcode349:
push rbp
mov rbp,rsp

;Start of sub expr 
;(+ acc 1)


; ApplicTP

mov rax, const_tbl+51

push rax
;pushed arg 1
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg acc
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP352
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP352:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont349:


push rax
;pushed arg (lambda (acc e) (+ acc 1))
push 3  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP353
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP353:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 3
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont346:


leave
ret
Lcont345:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg344
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg344:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          mov qword [fvar_tbl+208],rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void




;START OF CODE of (define string->list ((lambda (string-ref string-length < - cons) (lambda (s) ((lambda (s->l-loop) (set! s->l-loop (box s->l-loop)) (begin (set! s->l-loop (lambda (n a) (if (< n 0) a (s->l-loop (- n 1) (cons (string-ref s n) a))))) (s->l-loop (- (string-length s) 1) '()))) 'whatever))) string-ref string-length < - cons))



;Start of sub expr 
;((lambda (string-ref string-length < - cons) (lambda (s) ((lambda (s->l-loop) (set! s->l-loop (box s->l-loop)) (begin (set! s->l-loop (lambda (n a) (if (< n 0) a (s->l-loop (- n 1) (cons (string-ref s n) a))))) (s->l-loop (- (string-length s) 1) '()))) 'whatever))) string-ref string-length < - cons)


; Applic

mov rax, qword [fvar_tbl+112]

push rax
;pushed arg cons
mov rax, qword [fvar_tbl+16]

push rax
;pushed arg -
mov rax, qword [fvar_tbl+32]

push rax
;pushed arg <
mov rax, qword [fvar_tbl+328]

push rax
;pushed arg string-length
mov rax, qword [fvar_tbl+336]

push rax
;pushed arg string-ref
push 5  ; number of args

;Start of sub expr 
;(lambda (string-ref string-length < - cons) (lambda (s) ((lambda (s->l-loop) (set! s->l-loop (box s->l-loop)) (begin (set! s->l-loop (lambda (n a) (if (< n 0) a (s->l-loop (- n 1) (cons (string-ref s n) a))))) (s->l-loop (- (string-length s) 1) '()))) 'whatever)))

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode355)
jmp Lcont355
Lcode355:
push rbp
mov rbp,rsp

;Start of sub expr 
;(lambda (s) ((lambda (s->l-loop) (set! s->l-loop (box s->l-loop)) (begin (set! s->l-loop (lambda (n a) (if (< n 0) a (s->l-loop (- n 1) (cons (string-ref s n) a))))) (s->l-loop (- (string-length s) 1) '()))) 'whatever))

MALLOC rbx, (1+1)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 1
loop357:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop357    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop358:
cmp rcx, r8
je end_loop358
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop358
end_loop358:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode356)
jmp Lcont356
Lcode356:
push rbp
mov rbp,rsp

;Start of sub expr 
;((lambda (s->l-loop) (set! s->l-loop (box s->l-loop)) (begin (set! s->l-loop (lambda (n a) (if (< n 0) a (s->l-loop (- n 1) (cons (string-ref s n) a))))) (s->l-loop (- (string-length s) 1) '()))) 'whatever)


; ApplicTP

mov rax, const_tbl+23

push rax
;pushed arg 'whatever
push 1  ; number of args

;Start of sub expr 
;(lambda (s->l-loop) (set! s->l-loop (box s->l-loop)) (begin (set! s->l-loop (lambda (n a) (if (< n 0) a (s->l-loop (- n 1) (cons (string-ref s n) a))))) (s->l-loop (- (string-length s) 1) '())))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop361:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop361    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop362:
cmp rcx, r8
je end_loop362
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop362
end_loop362:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode360)
jmp Lcont360
Lcode360:
push rbp
mov rbp,rsp
MALLOC rcx, 8*1   ;allocate memory to box param
mov rax, qword [rbp + 8 * (4 + 0)]
mov [rcx], qword rax
mov rax, rcx
mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS


;Start of sub expr 
;(lambda (n a) (if (< n 0) a (s->l-loop (- n 1) (cons (string-ref s n) a))))

MALLOC rbx, (1+3)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 3
loop364:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop364    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop365:
cmp rcx, r8
je end_loop365
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop365
end_loop365:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode363)
jmp Lcont363
Lcode363:
push rbp
mov rbp,rsp

;Start of sub expr 
;(if (< n 0) a (s->l-loop (- n 1) (cons (string-ref s n) a)))



;Start of sub expr 
;(< n 0)


; Applic

mov rax, const_tbl+34

push rax
;pushed arg 0
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg n
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*2]		;rax<-rib (=major)
mov rax,qword[rax+8*2]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg366
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg366:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse371
mov rax, qword [rbp + 8 * (4 + 1)]

jmp Lexit371
Lelse371:

;Start of sub expr 
;(s->l-loop (- n 1) (cons (string-ref s n) a))


; ApplicTP


;Start of sub expr 
;(cons (string-ref s n) a)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg a

;Start of sub expr 
;(string-ref s n)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg n
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)

push rax
;pushed arg s
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*2]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg367
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg367:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (string-ref s n)
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*2]		;rax<-rib (=major)
mov rax,qword[rax+8*4]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg368
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg368:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (cons (string-ref s n) a)

;Start of sub expr 
;(- n 1)


; Applic

mov rax, const_tbl+51

push rax
;pushed arg 1
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg n
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*2]		;rax<-rib (=major)
mov rax,qword[rax+8*3]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg369
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg369:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (- n 1)
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)
mov rax, qword [rax]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP370
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP370:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

Lexit371:

leave
ret
Lcont363:

push rax
mov rax, qword [rbp + 8 * (4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS


;Start of sub expr 
;(s->l-loop (- (string-length s) 1) '())


; ApplicTP

mov rax, const_tbl+1

push rax
;pushed arg '()

;Start of sub expr 
;(- (string-length s) 1)


; Applic

mov rax, const_tbl+51

push rax
;pushed arg 1

;Start of sub expr 
;(string-length s)


; Applic

mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)

push rax
;pushed arg s
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg372
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg372:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (string-length s)
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*3]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg373
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg373:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (- (string-length s) 1)
push 2  ; number of args
mov rax, qword [rbp + 8 * (4 + 0)]
mov rax, qword [rax]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP374
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP374:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code



leave
ret
Lcont360:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP359
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP359:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 1
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont356:


leave
ret
Lcont355:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg354
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg354:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          mov qword [fvar_tbl+320],rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void




;START OF CODE of (define equal? ((lambda (= string->list rational? flonum? pair? char? string? eq? car cdr char->integer) ((lambda (equal?-loop) (set! equal?-loop (box equal?-loop)) (begin (set! equal?-loop (lambda (x y) (if (if (rational? x) (rational? y) #f) (= x y) (if (if (flonum? x) (flonum? y) #f) (= x y) (if (if (char? x) (char? y) #f) (= (char->integer x) (char->integer y)) (if (if (pair? x) (pair? y) #f) (if (equal?-loop (car x) (car y)) (equal?-loop (cdr x) (cdr y)) #f) (if (if (string? x) (string? y) #f) (equal?-loop (string->list x) (string->list y)) (eq? x y)))))))) equal?-loop)) 'whatever)) = string->list rational? flonum? pair? char? string? eq? car cdr char->integer))



;Start of sub expr 
;((lambda (= string->list rational? flonum? pair? char? string? eq? car cdr char->integer) ((lambda (equal?-loop) (set! equal?-loop (box equal?-loop)) (begin (set! equal?-loop (lambda (x y) (if (if (rational? x) (rational? y) #f) (= x y) (if (if (flonum? x) (flonum? y) #f) (= x y) (if (if (char? x) (char? y) #f) (= (char->integer x) (char->integer y)) (if (if (pair? x) (pair? y) #f) (if (equal?-loop (car x) (car y)) (equal?-loop (cdr x) (cdr y)) #f) (if (if (string? x) (string? y) #f) (equal?-loop (string->list x) (string->list y)) (eq? x y)))))))) equal?-loop)) 'whatever)) = string->list rational? flonum? pair? char? string? eq? car cdr char->integer)


; Applic

mov rax, qword [fvar_tbl+96]

push rax
;pushed arg char->integer
mov rax, qword [fvar_tbl+88]

push rax
;pushed arg cdr
mov rax, qword [fvar_tbl+80]

push rax
;pushed arg car
mov rax, qword [fvar_tbl+136]

push rax
;pushed arg eq?
mov rax, qword [fvar_tbl+352]

push rax
;pushed arg string?
mov rax, qword [fvar_tbl+104]

push rax
;pushed arg char?
mov rax, qword [fvar_tbl+280]

push rax
;pushed arg pair?
mov rax, qword [fvar_tbl+160]

push rax
;pushed arg flonum?
mov rax, qword [fvar_tbl+296]

push rax
;pushed arg rational?
mov rax, qword [fvar_tbl+320]

push rax
;pushed arg string->list
mov rax, qword [fvar_tbl+40]

push rax
;pushed arg =
push 11  ; number of args

;Start of sub expr 
;(lambda (= string->list rational? flonum? pair? char? string? eq? car cdr char->integer) ((lambda (equal?-loop) (set! equal?-loop (box equal?-loop)) (begin (set! equal?-loop (lambda (x y) (if (if (rational? x) (rational? y) #f) (= x y) (if (if (flonum? x) (flonum? y) #f) (= x y) (if (if (char? x) (char? y) #f) (= (char->integer x) (char->integer y)) (if (if (pair? x) (pair? y) #f) (if (equal?-loop (car x) (car y)) (equal?-loop (cdr x) (cdr y)) #f) (if (if (string? x) (string? y) #f) (equal?-loop (string->list x) (string->list y)) (eq? x y)))))))) equal?-loop)) 'whatever))

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode376)
jmp Lcont376
Lcode376:
push rbp
mov rbp,rsp

;Start of sub expr 
;((lambda (equal?-loop) (set! equal?-loop (box equal?-loop)) (begin (set! equal?-loop (lambda (x y) (if (if (rational? x) (rational? y) #f) (= x y) (if (if (flonum? x) (flonum? y) #f) (= x y) (if (if (char? x) (char? y) #f) (= (char->integer x) (char->integer y)) (if (if (pair? x) (pair? y) #f) (if (equal?-loop (car x) (car y)) (equal?-loop (cdr x) (cdr y)) #f) (if (if (string? x) (string? y) #f) (equal?-loop (string->list x) (string->list y)) (eq? x y)))))))) equal?-loop)) 'whatever)


; ApplicTP

mov rax, const_tbl+23

push rax
;pushed arg 'whatever
push 1  ; number of args

;Start of sub expr 
;(lambda (equal?-loop) (set! equal?-loop (box equal?-loop)) (begin (set! equal?-loop (lambda (x y) (if (if (rational? x) (rational? y) #f) (= x y) (if (if (flonum? x) (flonum? y) #f) (= x y) (if (if (char? x) (char? y) #f) (= (char->integer x) (char->integer y)) (if (if (pair? x) (pair? y) #f) (if (equal?-loop (car x) (car y)) (equal?-loop (cdr x) (cdr y)) #f) (if (if (string? x) (string? y) #f) (equal?-loop (string->list x) (string->list y)) (eq? x y)))))))) equal?-loop))

MALLOC rbx, (1+1)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 1
loop379:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop379    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop380:
cmp rcx, r8
je end_loop380
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop380
end_loop380:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode378)
jmp Lcont378
Lcode378:
push rbp
mov rbp,rsp
MALLOC rcx, 8*1   ;allocate memory to box param
mov rax, qword [rbp + 8 * (4 + 0)]
mov [rcx], qword rax
mov rax, rcx
mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS


;Start of sub expr 
;(lambda (x y) (if (if (rational? x) (rational? y) #f) (= x y) (if (if (flonum? x) (flonum? y) #f) (= x y) (if (if (char? x) (char? y) #f) (= (char->integer x) (char->integer y)) (if (if (pair? x) (pair? y) #f) (if (equal?-loop (car x) (car y)) (equal?-loop (cdr x) (cdr y)) #f) (if (if (string? x) (string? y) #f) (equal?-loop (string->list x) (string->list y)) (eq? x y)))))))

MALLOC rbx, (1+2)*8
mov rdx, qword [rbp+8*2]     ; rdx points to curr lexical env
mov rcx, 0
mov r8, 2
loop382:
mov r9, qword [rdx + rcx*8]
mov qword [rbx + (rcx+1)*8], r9    ; ext_env[i+1] <- lex_env[i]
inc rcx
cmp rcx, r8    ; are we finished?
jne loop382    ; if not, repeat
; now copy current params
mov r8,  qword [rbp + (8*3)]   ; r8=len(params)
shl r8, 3        ; number of bytes
MALLOC rdx, r8   ; accumulate params in rdx
shr r8, 3        ; restore number of params
mov rcx, 0       ; set loop counter
loop383:
cmp rcx, r8
je end_loop383
mov r11, PVAR(rcx)

mov qword [rdx + 8*(rcx)], r11
inc rcx
jmp loop383
end_loop383:
mov qword [rbx], rdx   ; rbx is the pointer to ExtEnv, rbx[0] <- rdx
MAKE_CLOSURE(rax, rbx, Lcode381)
jmp Lcont381
Lcode381:
push rbp
mov rbp,rsp

;Start of sub expr 
;(if (if (rational? x) (rational? y) #f) (= x y) (if (if (flonum? x) (flonum? y) #f) (= x y) (if (if (char? x) (char? y) #f) (= (char->integer x) (char->integer y)) (if (if (pair? x) (pair? y) #f) (if (equal?-loop (car x) (car y)) (equal?-loop (cdr x) (cdr y)) #f) (if (if (string? x) (string? y) #f) (equal?-loop (string->list x) (string->list y)) (eq? x y))))))



;Start of sub expr 
;(if (rational? x) (rational? y) #f)



;Start of sub expr 
;(rational? x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*2]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg384
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg384:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse386

;Start of sub expr 
;(rational? y)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*2]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg385
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg385:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
jmp Lexit386
Lelse386:
mov rax, const_tbl+2

Lexit386:

cmp rax, SOB_FALSE_ADDRESS
je Lelse419

;Start of sub expr 
;(= x y)


; ApplicTP

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP387
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP387:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

jmp Lexit419
Lelse419:

;Start of sub expr 
;(if (if (flonum? x) (flonum? y) #f) (= x y) (if (if (char? x) (char? y) #f) (= (char->integer x) (char->integer y)) (if (if (pair? x) (pair? y) #f) (if (equal?-loop (car x) (car y)) (equal?-loop (cdr x) (cdr y)) #f) (if (if (string? x) (string? y) #f) (equal?-loop (string->list x) (string->list y)) (eq? x y)))))



;Start of sub expr 
;(if (flonum? x) (flonum? y) #f)



;Start of sub expr 
;(flonum? x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*3]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg388
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg388:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse390

;Start of sub expr 
;(flonum? y)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*3]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg389
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg389:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
jmp Lexit390
Lelse390:
mov rax, const_tbl+2

Lexit390:

cmp rax, SOB_FALSE_ADDRESS
je Lelse418

;Start of sub expr 
;(= x y)


; ApplicTP

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP391
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP391:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

jmp Lexit418
Lelse418:

;Start of sub expr 
;(if (if (char? x) (char? y) #f) (= (char->integer x) (char->integer y)) (if (if (pair? x) (pair? y) #f) (if (equal?-loop (car x) (car y)) (equal?-loop (cdr x) (cdr y)) #f) (if (if (string? x) (string? y) #f) (equal?-loop (string->list x) (string->list y)) (eq? x y))))



;Start of sub expr 
;(if (char? x) (char? y) #f)



;Start of sub expr 
;(char? x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*5]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg392
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg392:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse394

;Start of sub expr 
;(char? y)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*5]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg393
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg393:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
jmp Lexit394
Lelse394:
mov rax, const_tbl+2

Lexit394:

cmp rax, SOB_FALSE_ADDRESS
je Lelse417

;Start of sub expr 
;(= (char->integer x) (char->integer y))


; ApplicTP


;Start of sub expr 
;(char->integer y)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*10]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg395
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg395:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (char->integer y)

;Start of sub expr 
;(char->integer x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*10]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg396
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg396:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (char->integer x)
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP397
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP397:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

jmp Lexit417
Lelse417:

;Start of sub expr 
;(if (if (pair? x) (pair? y) #f) (if (equal?-loop (car x) (car y)) (equal?-loop (cdr x) (cdr y)) #f) (if (if (string? x) (string? y) #f) (equal?-loop (string->list x) (string->list y)) (eq? x y)))



;Start of sub expr 
;(if (pair? x) (pair? y) #f)



;Start of sub expr 
;(pair? x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*4]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg398
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg398:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse400

;Start of sub expr 
;(pair? y)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*4]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg399
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg399:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
jmp Lexit400
Lelse400:
mov rax, const_tbl+2

Lexit400:

cmp rax, SOB_FALSE_ADDRESS
je Lelse416

;Start of sub expr 
;(if (equal?-loop (car x) (car y)) (equal?-loop (cdr x) (cdr y)) #f)



;Start of sub expr 
;(equal?-loop (car x) (car y))


; Applic


;Start of sub expr 
;(car y)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*8]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg401
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg401:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (car y)

;Start of sub expr 
;(car x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*8]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg402
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg402:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (car x)
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)
mov rax, qword [rax]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg403
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg403:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse407

;Start of sub expr 
;(equal?-loop (cdr x) (cdr y))


; ApplicTP


;Start of sub expr 
;(cdr y)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*9]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg404
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg404:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (cdr y)

;Start of sub expr 
;(cdr x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*9]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg405
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg405:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (cdr x)
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)
mov rax, qword [rax]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP406
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP406:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

jmp Lexit407
Lelse407:
mov rax, const_tbl+2

Lexit407:

jmp Lexit416
Lelse416:

;Start of sub expr 
;(if (if (string? x) (string? y) #f) (equal?-loop (string->list x) (string->list y)) (eq? x y))



;Start of sub expr 
;(if (string? x) (string? y) #f)



;Start of sub expr 
;(string? x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*6]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg408
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg408:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
cmp rax, SOB_FALSE_ADDRESS
je Lelse410

;Start of sub expr 
;(string? y)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*6]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg409
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg409:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
jmp Lexit410
Lelse410:
mov rax, const_tbl+2

Lexit410:

cmp rax, SOB_FALSE_ADDRESS
je Lelse415

;Start of sub expr 
;(equal?-loop (string->list x) (string->list y))


; ApplicTP


;Start of sub expr 
;(string->list y)


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg411
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg411:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (string->list y)

;Start of sub expr 
;(string->list x)


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 1  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*1]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg412
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg412:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
push rax
;pushed arg (string->list x)
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*0]		;rax<-rib (=major)
mov rax,qword[rax+8*0]		;rax<-rib (=minor)
mov rax, qword [rax]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP413
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP413:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

jmp Lexit415
Lelse415:

;Start of sub expr 
;(eq? x y)


; ApplicTP

mov rax, qword [rbp + 8 * (4 + 1)]

push rax
;pushed arg y
mov rax, qword [rbp + 8 * (4 + 0)]

push rax
;pushed arg x
push 2  ; number of args
mov rax, qword[rbp+8*2]		;rax<-env
mov rax,qword[rax+8*1]		;rax<-rib (=major)
mov rax,qword[rax+8*7]		;rax<-rib (=minor)


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP414
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP414:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

Lexit415:

Lexit416:

Lexit417:

Lexit418:

Lexit419:

leave
ret
Lcont381:

push rax
mov rax, qword [rbp + 8 * (4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS

mov rax, qword [rbp + 8 * (4 + 0)]
mov rax, qword [rax]



leave
ret
Lcont378:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP377
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP377:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 1
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont376:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg375
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg375:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          mov qword [fvar_tbl+144],rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void




;START OF CODE of ((lambda (x) (eq? (if #f #f) (set! x 2))) 1)



;Start of sub expr 
;((lambda (x) (eq? (if #f #f) (set! x 2))) 1)


; Applic

mov rax, const_tbl+51

push rax
;pushed arg 1
push 1  ; number of args

;Start of sub expr 
;(lambda (x) (eq? (if #f #f) (set! x 2)))

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode421)
jmp Lcont421
Lcode421:
push rbp
mov rbp,rsp

;Start of sub expr 
;(eq? (if #f #f) (set! x 2))


; ApplicTP

mov rax, const_tbl+85
mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS

push rax
;pushed arg (set! x 2)

;Start of sub expr 
;(if #f #f)


mov rax, const_tbl+2

cmp rax, SOB_FALSE_ADDRESS
je Lelse422
mov rax, const_tbl+2

jmp Lexit422
Lelse422:
mov rax, const_tbl+0

Lexit422:

push rax
;pushed arg (if #f #f)
push 2  ; number of args
mov rax, qword [fvar_tbl+136]


          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppTP423
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppTP423:
          
          push qword [rax + TYPE_SIZE]  ; push env
          push qword [rbp + WORD_SIZE]  ; old ret addr
          
          ; find the size of previous frame = loop counter
          mov qword r10, 2
          add r10, 1       ; loop is going to start from 1
          add r10, 3       ; for (n, env, ret)
          SHIFT_FRAME r10
          
jmp qword [rax + TYPE_SIZE + WORD_SIZE]  ; jmp to code

leave
ret
Lcont421:



          cmp byte [rax], T_CLOSURE
          je continue_evaluation_AppReg420
          mov ecx, 0
          div ecx      ; divide by zero to create exception
          continue_evaluation_AppReg420:
          
          push qword [rax + TYPE_SIZE]  ; push env
          call qword [rax + TYPE_SIZE + WORD_SIZE]  ; call code
          
          add rsp , 8*1       ; pop env
          pop rbx             ; pop arg count
          lea rsp , [rsp + 8*rbx]
          
	call write_sob_if_not_void;;; Clean up the dummy frame, set the exit status to 0 ("success"), 
   ;;; and return from main
   pop rbp
   add rsp, 3*8
   mov rax, 0

   ret
boolean?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_BOOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

flonum?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_FLOAT
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

rational?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_RATIONAL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

pair?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_PAIR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

null?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_NIL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CHAR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_STRING
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

symbol?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_SYMBOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

procedure?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CLOSURE
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

div:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .div_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  divsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .div_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          MAKE_RATIONAL(rax, rdx, rdi)
         mov PVAR(1), rax
         pop rbp
         jmp mul
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

mul:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .mul_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  mulsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .mul_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

add:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .add_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  addsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .add_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdx
	 imul rdi, rcx
	 add rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

eq:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .eq_rat
             FLOAT_VAL rsi, rsi
	 FLOAT_VAL rdi, rdi
	 cmp rsi, rdi
             jmp .op_return
          .eq_rat:
             NUMERATOR rcx, rsi
	 NUMERATOR rdx, rdi
	 cmp rcx, rdx
	 jne .false
	 DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 cmp rcx, rdx
         .false:
          .op_return:
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

lt:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .lt_rat
             FLOAT_VAL rsi, rsi
	 movq xmm0, rsi
	 FLOAT_VAL rdi, rdi
	 movq xmm1, rdi
	 cmpltpd xmm0, xmm1
         movq rsi, xmm0
         cmp rsi, 0
             jmp .op_return
          .lt_rat:
             DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 NUMERATOR rsi, rsi
	 NUMERATOR rdi, rdi
	 imul rsi, rdx
	 imul rdi, rcx
	 cmp rsi, rdi
          .op_return:
      jl .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string_length:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	STRING_LENGTH rsi, rsi
         MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

string_ref:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         mov sil, byte [rsi]
         MAKE_CHAR(rax, sil)
         pop rbp
         ret

string_set:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov rdx, PVAR(2)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         CHAR_VAL rax, rdx
         mov byte [rsi], al
         mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

make_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	NUMERATOR rsi, rsi
         CHAR_VAL rdi, rdi
         and rdi, 255
         MAKE_STRING rax, rsi, dil
         pop rbp
         ret

symbol_to_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	SYMBOL_VAL rsi, rsi
	 STRING_LENGTH rcx, rsi
	 STRING_ELEMENTS rdi, rsi
	 push rcx
	 push rdi
	 mov dil, byte [rdi]
	 MAKE_CHAR(rax, dil)
	 push rax
	 MAKE_RATIONAL(rax, rcx, 1)
	 push rax
	 push 2
	 push SOB_NIL_ADDRESS
	 call make_string
	 add rsp, 4*8
	 STRING_ELEMENTS rsi, rax   
	 pop rdi
	 pop rcx
	 cmp rcx, 0
	 je .end
         .loop:
	 lea r8, [rdi+rcx]
	 lea r9, [rsi+rcx]
	 mov bl, byte [r8]
	 mov byte [r9], bl
	 loop .loop
         .end:
         pop rbp
         ret

eq?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	cmp rsi, rdi
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char_to_integer:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CHAR_VAL rsi, rsi
	 and rsi, 255
	 MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

integer_to_char:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 and rsi, 255
	 MAKE_CHAR(rax, sil)
         pop rbp
         ret

exact_to_inexact:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rdi, rsi
	 NUMERATOR rsi, rsi 
	 cvtsi2sd xmm0, rsi
	 cvtsi2sd xmm1, rdi
	 divsd xmm0, xmm1
	 movq rsi, xmm0
	 MAKE_FLOAT(rax, rsi)
         pop rbp
         ret

numerator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

denominator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

gcd:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	xor rdx, rdx
	 NUMERATOR rax, rsi
         NUMERATOR rdi, rdi
         .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	 mov rdx, rax
         cmp rdx, 0
         jge .make_result
         neg rdx
         .make_result:
         MAKE_RATIONAL(rax, rdx, 1)
         pop rbp
         ret

car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CAR rax, rsi
         pop rbp
         ret

cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CDR rax, rsi
         pop rbp
         ret

cons:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	MAKE_PAIR(rax, rsi ,rdi)
         pop rbp
         ret

set_car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov qword [rsi+TYPE_SIZE],rdi
mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

set_cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov qword [rsi+TYPE_SIZE+WORD_SIZE],rdi
mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret


    apply:
      push rbp
      mov rbp, rsp
      mov rcx, qword[rbp + 8 * 3]
      sub rcx, 2
      dec rcx
      xor rdi, rdi ;; arg counter
      xor rsi, rsi
      Push_All_prim_args:
        cmp rcx, 0
        jl Exit_Push_All_prim_args
        xor r10,r10
        mov r10, rsi
        add r10, 5
        push qword[rbp + 8 * r10]
        inc rdi
        inc rsi
        dec rcx
        jmp Push_All_prim_args
      Exit_Push_All_prim_args:

      mov rcx, qword[rbp + 8 * 3]
      add rcx, 4
      dec rcx
      mov r12, rbp
      mov r13, rcx
      IMUL r13, 8
      add r12, r13                 
      mov rbx, qword[rbp + 8 * rcx] 

      Push_List_args:
        cmp rbx, SOB_NIL_ADDRESS
        je Exit_Push_List_args
        add rbx, 1
        push qword[rbx]
        inc rdi
        mov rbx, qword[rbx + 8]
        jmp Push_List_args
      Exit_Push_List_args:
      push rdi               
      xor rcx, rcx
      inc rcx
      Swap:
        cmp rcx, rdi
        jge Exit_Swap

        mov r8, rcx
        IMUL r8, (-1)
        mov rbx, qword[rbp + 8 * r8]

        mov r8, rdi
        IMUL r8, (-1)
        mov rax, qword[rbp + 8 * r8]

        mov r8, rdi
        IMUL r8, (-1)
        mov qword[rbp + 8 * r8], rbx
        mov r8, rcx
        IMUL r8, (-1)
        mov qword[rbp + 8 * r8], rax
        inc rcx
        dec rdi
        jmp Swap
      Exit_Swap:

      mov rsi, qword[rsp]         
      mov rax, qword[rbp + 8 * 4] 
      mov rdx, qword[rbp + 8 * 3]
      add rdx, 4                  
      dec rdx
      inc rax
      push qword[rax]             
      mov rcx, qword[rbp + 8 * 1] 
      push rcx                   
      mov rcx, qword[rbp]        
      add rsi, 3
      dec rsi
      xor rbx, rbx
      inc rbx
      apply_fix_stack:
        cmp rsi, 0
        jl apply_finish_fix_stack
        mov r8, rbx
        IMUL r8, (-1)
        mov r13, qword[rbp + 8 * r8]
        mov qword[r12], r13

        sub r12, 8
        dec rsi
        inc rbx
        jmp apply_fix_stack
      apply_finish_fix_stack:
      add r12, 8
      mov rsp, r12
      mov rbp, rcx
      add rax, 8
      mov rax, qword[rax]
      jmp rax
    